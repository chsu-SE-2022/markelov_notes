<html>
<head>
   <title>Прикладное программирование</title>

</head>

<body background="fon.jpg">
<div align="center"><b><font>6.3. Прикладное программирование</font></b></div><font size = "-1">

<p align=justify>В предыдущих главах, рассматривая предложения SQL, мы практически не оговаривали, откуда попадают в СУБД такие запросы. Молчаливо предполагалось, что язык используется в интерактивном режиме и запросы вводятся с клавиатуры. Однако все предложения SQL, которые можно ввести с терминала, можно использовать также в прикладной программе.</p>
<p align=justify>Многие современные СУБД имеют собственные языки программирования, ряд которых включает в себя SQL. Другие работают с программами, написанными на одном из распространенных алгоритмических языков (Си, Паскаль или Фортран), в которые включаются предложения SQL. Для обмена информацией с частями программы, написанными на любых из этих языков, существуют специальные конструкции SQL, позволяющие работать с переменными и (или) отдельными строками таблиц.</p>
<p align=justify>Переменные включающего языка:</p>
<ul>
<LI>могут появляться в предложениях манипулирования данными языка SQL только во фразах SELECT и INTO предложения SELECT, фразе WHERE предложений SELECT, UPDATE и DELETE, фразе SET предложения UPDATE, фразе VALUES предложения INSERT и, наконец, в качестве элемента выражения во фразах SELECT, WHERE или SET, но не VALUES;
<LI>должны иметь типы данных, совместимые с типами данных тех столбцов базы данных, с которыми они должны сравниваться, значения которых им должны быть присвоены или которым должны быть присвоены значения переменных;
<LI>могут иметь имена, совпадающие с именами столбцов базы данных (система различает их по месторасположению в предложениях SQL или по специальному символу, например, ".", устанавливаемому перед именем переменной, когда надо использовать ее значение).</ul>
<p align=justify>После выполнения любого предложения SQL происходит обновление системной переменной SQLCODE (в нее заносится числовой индикатор состояния). Нулевое значение SQLCODE означает, что данное предложение выполнено успешно. Положительное значение означает, что предложение выполнено, но имела место некоторая исключительная ситуация. Например, значение +100 указывает, что не было найдено никаких данных, удовлетворяющих запросу. Наконец, отрицательное значение указывает, что имела место ошибка и предложение не выполнено. Поэтому за каждым предложением SQL в программе должна следовать проверка значения SQLCODE и должно предприниматься соответствующее действие, если это значение оказалось не таким, которое ожидалось. На практике же такую проверку осуществляют после тех предложений SQL, при выполнении которых возможна исключительная ситуация).</p>
<p align=justify>Основная проблема "встраивания" предложения SELECT в программу заключается в том, что SELECT, как правило, порождает таблицу с множеством строк и столбцов, а включающий язык не обладает хорошими средствами, позволяющими оперировать одновременно более чем одной записью (строкой). По этим причинам необходимо обеспечить своего рода мост между уровнем множеств языка SQL и уровнем записей включающего языка. Такой мост обеспечивают курсоры. Курсор состоит, по существу, из некоторого рода указателя, который может использоваться для просмотра множества записей. Поочередно указывая каждую запись в данном множестве, он обеспечивает возможность обращения к этим записям по одной одновременно.</p>
<p align=justify>Однако нередко программе требуются в каждый момент времени значения только из одной строки какой-либо таблицы, и для этого используется единичное SELECT, формат которого имеет вид</p>
<pre>
SELECT [[ALL] | DISTINCT]{ * | элемент_select 
                                 [,элемент_select] ...}
INTO	переменная [[INDICATOR] индикаторная_переменная]
[,переменная [[INDICATOR] индикаторная_переменная]] ...
FROM	базовая_таблица | представление [псевдоним]
	[,базовая_таблица | представление [псевдоним]] ...
[WHERE	фраза]
[GROUP	BY фраза [HAVING фраза]];
</pre>
<p align=justify>где элемент_select - это одна из следующих конструкций:</p>
<pre>
[таблица.]* | [таблица.]столбец | SQL_функция |
 переменная | (выражение) | системная_переменная
</pre>
<p align=justify>Очевидно, что это описание отличается от описания подзапроса (п.<a href=2-1.htm>2.1</a>) наличием фразы INTO и включением в список элементов_select переменных. Переменные могут также включаться в выражения и фразы WHERE и HAVING.</p>
<p align=justify>Приведем несколько примеров. Получить общий вес продуктов в кладовой пансионата и занести его в переменную Общий_вес:</p>
<pre>
SELECT	SUM(К_во)
INTO	Общий_вес
FROM	Наличие;
</pre>
<p align=justify>Здесь определяется единственное значение (сумма данных в столб-це) и поэтому системная переменная SQLCODE устанавливается в нуль.</p>
<p align=justify>Однако в следующем примере</p>
<pre>
SELECT	Продукт, К_во
INTO	Продукт, К_продукта
FROM	Наличие, Продукты
WHERE	Наличие.ПР = Продукты.ПР
AND	ПР IN
	(	SELECT ПР
		FROM	Продукты
		WHERE  Продукт = 'Икра черная');
</pre>
<p align=justify>где требовалось узнать количество черной икры в кладовой пансионата и занести название этого продукта и его количество в переменные Продукт и К_продукта, соответственно, переменная SQLCODE примет значение +100, так как в кладовой нет икры.</p>
<p align=justify>Наконец, в примере</p>
<pre>
SELECT	Продукт, К_во
INTO	Продукт, К_продукта
FROM	Наличие, Продукты
WHERE	Наличие.ПР = Продукты.ПР;
</pre>	
<p align=justify>где не указан конкретный продукт и, следовательно, SELECT спродуцирует вывод всей таблицы продуктов, значение SQLCODE будет отрицательным. При этом значения переменных Продукт и К_продукта останутся неизменными, т.е. такими, какими они были после последнего правильного выполнения команды.</p>
<p align=justify>В единичном SELECT можно ввести за каждой целевой переменной слово INDICATOR и имя индикаторной переменной. Значения индикаторных переменных не равны нулю только при нулевом значении SQLCODE и NULL-значениях элементов SELECT для соответствующих целевых переменных. Например, если в столбцах К_во и Стоимость продукта 9 хранится значение NULL, то после выполнения запроса</p>
<pre>
SELECT	ПР, К_во, Стоимость
INTO	ПР INDICATOR Инд1, К_прод INDICATOR Инд2,
	Стоим INDICATOR Инд3
FROM	Наличие
WHERE	ПР = 9;
</pre>
<p align=justify>будут получены следующие значения переменных: SQLCODE = 0, ПР = 9, Инд1 = 0, Инд2 = Инд3 = -1, а К_прод и Стоим имеют значение NULL.</p>
<p align=justify>Переменные можно использовать и в предложениях модификации данных. Приведем несколько примеров.</p>
<p align=justify>Изменить цены продуктов ленинградских поставщиков на величину, заданную переменной Измен:</p>
<pre>
UPDATE	Поставки
SET	Цена = Цена + .Измен
WHERE	ПС IN
	(SELECT	ПC
		FROM	Поставщики
		WHERE	Город = 'Ленинград');
</pre>
<p align=justify>Удалить все блюда, основа которых указана в переменной Осн:</p>
<pre>
DELETE
FROM	Блюда
WHERE	Основа = .Осн;
</pre>
<p align=justify>Добавить в таблицу Поставщики нового поставщика, атрибуты которого заданы соответствующими переменными ПС, Имя, Статус, Город, а Адрес и Телефон неизвестны:</p>
<pre>
INSERT
INTO 	Поставщики
	(ПС, Название, Статус, Город)
VALUES	(.ПС, .Имя, .Статус, .Город);
</pre>
<p align=justify>В тех же приложениях, где надо отыскивать и обрабатывать множество подходящих записей из одной таблицы или совокупности таблиц базы данных следует использовать курсоры, позволяющие организовать последовательный доступ к строкам какой-либо таблицы (соединению таблиц, представлению и т.п.).</p>
<p align=justify>Предложение</p>
<pre>
DECLARE имя_курсора CURSOR
FOR подзапрос
</pre>
<p align=justify>определяет имя курсора и связанный с ним подзапрос. С его помощью идентифицируется некоторое множество столбцов и строк указаной таблицы (совокупности таблиц), которое становится активным множеством для данного курсора. (Точнее говоря, определяется множество частей строк, в которые входят только значения из указанных столбцов.) Курсор идентифицирует также позицию в этом множестве (сначала это позиция его первой записи). Активные множества всегда рассматриваются как упорядоченные. При этом упорядочение определяется фразой ORDER BY, а при ее отсутствии – системой (в порядке загрузки строк в таблицу).</p>
<p align=justify>Описанные с помощью DECLARE CURSOR множества используются рядом предложений SQL для удаления отмеченных строк (DELETE), их модификации (UPDATE) или присвоения значений перечисленных в SELECT столбцов переменным, список которых указывается в предложении FETCH (вызвать). Однако перед выполнением этих команд необходимо активизировать курсор, который в этот момент не должен быть открыт. Для этого используется предложение OPEN (OPEN имя_курсора).</p>
<p align=justify>Предложение FETCH используется для выборки той записи активного множества, на которую указывает курсор, для присвоения значений столбцов этой записи переменным, перечисленным во фразе INTO, и для перемещения курсора на следующую строку активного множества. При перемещении за последнюю строку переменная SQLCODE примет значение +100.</p>
<pre>
FETCH	имя_курсора
INTO	переменная [[INDICATOR] индикаторная_переменная]
{,переменная [[INDICATOR] индикаторная_переменная]} ...
</pre>
<p align=justify>Команду FETCH обычно помещают в некоторый цикл, размещая непосредственно за ней команду анализа SQLCODE. Это позволяет обнаружить переход от значения 0 на +100 и организовать выход из цикла.</p>
<p align=justify>Наконец, следует упомянуть еще два предложения, связанные с курсорами. Это предложение для дезактивации курсора (CLOSE имя_курсора) и предложение для уничтожения курсора (DROP CURSOR имя_курсора).</p>
<p align=justify>Мы уже отмечали, что ограниченный объем книги не позволяет подробнее обсудить и должным образом проиллюстрировать использование курсоров. Не затронуты также предложения COMMENT ON (ввести описание таблицы или столбца), CONNECT (открыть базу данных), DISCONNECT (закрыть базу данных), WHENEVER (организовать обработку индикатора ошибки SQL) и несколько предложений, связанных с управлением транзакциями и параллельным их исполнением. </p>
		
<p align="center">
<a href="6-2.htm">6.2</a> | <a href="index.htm">Содержание</a> | <a href="liter.htm">Литература</a>
</p>

</body>
</html>
