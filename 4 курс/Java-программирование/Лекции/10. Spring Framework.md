**Spring Framework** - облегченная платформа для построения enterprise-приложений на Java:
- Можно применять к любому Java-приложению, не привязана к web
- Облегченная - не размер дистрибутива, а степень воздействия на код
- Модульная структура (IoC, web, Data Access, Messaging, ...)
## Основа Spring
Ядро Spring Framework основано на принципе **инверсии управления (Inversion of Control - IoC)**, когда создание и управление зависимостями между компонентами становятся внешними.  
Мартин Фаулер назвал процесс внедрения зависимостей во время выполнения, приводящее к инверсии **Dependency Injection - DI**.
Реализация DI в Spring основана на 2 концепциях:
- JavaBean
- Интерфейсы
  
В Spring любой управляемый ресурс - это **bean**.  
С помощью интерфейсов можно получить максимальную отдачу от DI: бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.  
Конфигурирование через XML или классы Java, или аннотации в коде, или через Groovy.  
Основные преимущества DI:
- Сокращение объема связующего кода
- Упрощенная конфигурация приложения
- Возможность управления общими зависимостями в единственном репозитории
- Улучшенная возможность тестирования
  
Широчайший набор средств и инструментов:
- АОП (аспектно-ориентированное программирование)
- SpEL (Spring Expression Language)
- Валидация - проверка достоверности
- Доступ к данным реляционных БД, NoSQL, графовые и документные БД
- Управление транзакциями
- MVC на web-уровне
- Поддержка WebSocket
## Модули Spring
![Модули Spring](../Pictures/10_01.%20Модули%20Spring.png)  
## Три кита Spring-приложений
1. **Core** обеспечивает ключевые части фреймворка, включая свойства IoC и DI.  
2. **Beans** - это классы, созданием экземпляров которых и установкой в них зависимостей управляет контейнер фреймворка Spring.  
3. **Context** построен на основе Beans и Core и позволяет получать доступ к любому объекту, который определен в настройках. Ключевым элементов модуля Context является интерфейс `ApplicationContext`.
## Apache Maven
**Maven** - слово на идише, означающее "накопитель знаний".  
Инструмент, который можно использовать для созданий и управления любым проектом на основе Java:
- Упрощение процесса сборки
- Обеспечение единой системы сборки
- Предоставление качественной информации о проекте
- Поощрение лучших практик разработки
## Inversion of Control (IoC) - инверсия управления
Ядро Spring Framework основано на принципе **инверсии управления (Inversion of Control - IoC)**, когда создание и управление зависимостями между компонентами становятся внешними.
#### Проблема
```java
class ClassicalMusic {
	//...
}

class MusicPlayer {
	private ClassicalMusic cimusic;
	
	public void PlayMusic() {
	clmusic = newClassicalMusic();
	//...
	}
}
```
Сильная зависимость - класс `MusicPlayer` сильно зависит от класса `ClassicalMusic`.
#### Первое решение - интерфейс
```java
Interface Music {
	//...
}

class ClassicalMusic implements Music {
	//...
}

class RockMusic implements Music {
	//...
}

class MusicPlayer {
	private Music music;
	
	public void PlayMusic() {
		music = new ClassicalMusic();
		//...
		music = new RockMusic();
		//...
	}
}
```
Слабая зависимость - все классы создаются вручную внутри `MusicPlayer`.
#### Второе решение - beans
```java
Interface Music {
	//...
}

class ClassicalMusic implements Music {
	//...
}

class RockMusic implements Music {
	//...
}

class MusicPlayer {
	private Music music;
	
	public void PlayMusic() {
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
		
		music = context.getBean("classicMusic", ClassicalMusic.class);
		//...
		music = context.getBean("rockMusic", RockMusic.class);
	}
}
```
`MusicPlayer` сам создает свои зависимости.  
#### Inversion of Control
```java
Interface Music {
	//...
}

class ClassicalMusic implements Music {
	//...
}

class RockMusic implements Music {
	//...
}

class MusicPlayer {
	private Music music;
	
	public MusicPlayer(Music music) {
		this.music = music;
	}
	
	public void playMusic() {
		//...
	}
}
```
Сущность не сама создает свои зависимости, зависимости поставляются извне.  
Объект, который мы внедряем в `MusicPlayer` необходимо где-то создать.
```java
class Play {
	public static void main(String[] args) {
		MusicPlayer mp = new MusicPlayer(new RockMusic());
	}
}
```
Внедрение зависимостей - **Dependency Injection**.
```java
public class TestSpring {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("appContext.xml");
		Music music = context.getBean("musicBean", music.class);
		MusicPlayer musicPlayer = new MusicPlayer(music);
		musicPlayer.playMusic();
		context.close();
	}
}
```
## Dependency Injection (DI) - внедрение зависимостей
**Внедрение зависимости (DI - Dependency Injection)** - это процесс предоставления программному компоненту внешней зависимости. Согласно принципу единой обязанности, объект передает "заботу" о построении нужных ему зависимостей внешнему механизму, который специально для этого предназначен:
- Нулевое воздействие на код
- Легкость тестирования без привязки к контейнеру
#### Внедрение зависимостей с помощью конструктора
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic">
</bean>

<bean id = "musicPlayer"
	class = "ru.kmp.MusicPlayer">
	<constructor.arg ref = "musicBean"/>
</bean>
```
  
```java
public class TestSpring {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("appContext.xml");
		MusicPlayer musicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
		musicPlayer.playMusic();
		context.close();
	}
}
```
#### Внедрение зависимостей с помощью метода `setter`
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic">
</bean>

<bean id = "musicPlayer"
	class = "ru.kmp.MusicPlayer">
	<property name = "music" ref = "musicBean"/>
	
	<property name = "name" value = "Super Player"/>
	<property name = "volume" value = "80"/>
</bean>
```
  
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic">
	init-method = "doMyInit"
	destroy-method = "doMyDestroy"
</bean>

<bean id = "musicPlayer"
	class = "ru.kmp.MusicPlayer">
	<property name = "music" ref = "musicBean"/>
	
	<property name = "name" value = "${musicPlayer.name}"/>
	<property name = "volume" value = "${musicPlayer.volume}"/>
</bean>
```
## Scope
**Scope** задает то, как Spring будет создавать бины:
- `singleton`
- `prototype`
- `request`
- `session`
- `global-session`
- `websocket`
  
```xml
<bean id = "musicBean"
	class = "ru.kmp.MusicPlayer" scope = "prototype">
	<property name = "music" ref = "musicBean"/>
	
	<property name = "name" value = "Super Player"/>
	<property name = "volume" value = "80"/>	
</bean>
```
## Жизненный цикл бина (Bean Lifecycle)
![Жизненный цикл бина](../Pictures/10_02.%20Жизненный%20цикл%20бина.png)
## Описание методов в бине
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic"
	init-method = "doMyInt"
	destroy-method = "doMyDestroy"
	factory-method = "getClassialMusic">
</bean>
```
## Java-аннотации
**Java-аннотации** - это специальный тип комментариев в коде, с помощью которых можно:
- Передавать какие-либо инструкции для Java-компилятора (пример: аннотация `@Override`)
- Передавать какие-либо инструкции для анализаторов исходного кода
- Передавать метаданные, которые могут быть использованы либо Java-приложением (с помощью рефлексии), либо другими приложениями или фреймворками (пример: Spring Framework)
  
Как работает конфигурация с помощью аннотаций:
- Spring сканирует все классы
- Находит классы со специальными аннотациями и автоматически создает бины из этих классов
#### Способы конфигурации Spring-приложений
1. XML файл
2. XML + аннотации
3. Java-код + аннотации
#### Аннотация `@Component`
```java
@Component
public class RockMusic implements Music {
	@Override
	public String getSong() {
		return "Wind of change";
	}
}
```
- Помечаем ей класс, если хотим, чтобы Spring Framework создал бин из этого класса
- Именно эту аннотацию Spring Framework ищет, когда сканирует все классы
- Можно указать `id` для создаваемого бина, можно не указывать (тогда название будет `название_класса_с_маленькой_буквы`)
#### Аннотация `@Autowired`
Мы больше не внедряем зависимость вручную через XML файл. Spring сам ищет подходящий бин и автоматически внедряет его.  
Как работает аннотация `@Autowired`:
- Spring сканирует все классы с аннотацией `@Component` и создает бины для этих классов
- Spring сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве зависимости там, где мы указали аннотацию `@Autowired`
- Если находится один подходящий бин, он внедряется в качестве зависимости
- Если не находится ни одного бина - ошибка
- Если несколько бинов подходят - неоднозначность
  
В данном примере в бин `musicPlayer` необходимо внедрить бин, который реализует интерфейс `Music`:
```java
@Autowired
public MusicPlayer(Music music) {
	this.music = music;
}
```
Аннотация `@Autowired` позволяет внедрять зависимость в конструкторы, сеттеры и поля:
```java
@Autowired
public MusicPlayer(Music music) {
	this.music = music;
}

@Autowired
public void setMusic(Music music) {
	this.music = music;
}

@Autowired
private Music music;
```
#### Аннотация `@Qualifier`
`@Qualifier` - от английского "уточнитель"
```java
@Autowired
public MusicPlayer(@Qualifier("rockMusic") Music music) {
	this.music = music;
}

@Autowired
@Qualifier("rockMusic")
public void setMusic(Music music) {
	this.music = music;
}

@Autowired
@Qualifier("rockMusic")
	private Music music;
```
#### Аннотация `@Value`
```java
@Value("$(musicPlayer.name)")
private String name;
```
#### Аннотация `@Scope`
```java
@Component
@Scope("prototype")
public class ClassicalMusic implements Music {
	@Override
	public String getSong() {
		return "Moonlight Sonata";
	}
}
```
#### Другие аннотации
- Аннотация `@PostConstruct`
- Аннотация `@PreDestroy`
#### Аннотация `@Configuration`
Помечает Java-класс, который мы хотим использовать для конфигурации Spring-приложения
```java
@Configuration
public class SpringConfig {
}
```
Пустой конфигурационный Java-класс равен по функционалу пустому конфигурационному XML-файлу.  
Для каждого тега есть соответствующая конфигурация:
- `@ComponentScan("ru.kmp")`
- `@PropertySource("classpath:musicPlayer.properties")`
- `@Bean`
## Spring MVC
- Один из компонентов Spring Framework, который позволяет разрабатывать web-приложения на Java
- Spring MVC предполагает разработку web-приложений с использованием архитектуры Model - View - Controller
- Разрабатывая web-приложения, можно использовать все, что дает Spring Core - бины, внедрение зависимостей и т. д.
  
![MVC](../Pictures/10_03.%20MVC.png)  
**MVC** - паттерн проектирования приложений:
- **Model** - логика работы с данными
- **View** - логика представления, интерфейс
- **Controller** - логика навигации, обработка запросов
  
Из чего состоит Spring MVC приложение:
- Из обычных Java-классов (контроллеры, модели и прочее). Очень активно используются аннотации, которые применяются к классам и дают им дополнительные возможности (например, аннотация `@Controller`)
- Набор HTML-страниц (представления). К ним часто добавляется JavaScript-код, который "оживляет" HTML-представления и CSS, который стилизует HTML
- Spring-конфигурация (XML, аннотации или Java)
#### DispatcherServlet
![DispatcherServlet](../Pictures/10_04.%20DispatcherServlet.png)  
- Является входной точкой Spring MVC приложения
- Реализован за нас командой Spring
- Мы реализуем Модели, Представления и Контроллеры (MVC)
  
HTTP-запрос от пользователя:
1. Приходит на сервер. Сервер обрабатывается запрос и передает его на Spring MVC приложение
2. Запрос попадает в `DispatcherServlet`
3. `DispatcherServlet` отправляет запрос на правильный контроллер
#### Контроллер (Controller)
Контроллер реализуется нами.  
- Обрабатывает запросы от пользователя
- Обменивается данными с моделью
- Показывает пользователю правильное представление
- Переадресовывает пользователя на другие страницы
- ...
#### Модель (Model)
Модель реализуется нами.  
- Хранит в себе данные
- Взаимодействует с БД для получения данных
- Отдает данные контроллеру
- ...
#### Представление (View)
Представление реализуется нами.  
- Получает данные от контроллера и отображает их в браузере
- Для динамического отображения данных используются шаблонизаторы (Thymeleaf, Freemaker, Velocity)
  
Как создать первое MVC-приложение:
- Создать новое пустое Spring-приложение
- Подключить к IntelliJ IDEA web-сервер, например Tomcat
- Добавить необходимые зависимости в `pom.xml`
- Реализовать `web.xml` и `applicationContext.xml` файлы
- Реализовать контроллер, представление и модель
  
**Apache Tomcat** - это комплект серверных программ от Apache Software Foundation, предназначенный для тестирования, отладки и исполнения web-приложений на основе Java. Его обычно называют контейнеров сервлетов - дополнительных компонентов, которые расширяют функциональность web-сервера и позволяют ему выполнять приложения на языке Java