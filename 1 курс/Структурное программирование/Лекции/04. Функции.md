**Объявление и определение:**
```cpp
[класс] тип имя([список папаметров]) [throws (исключения)]
	{тело функции}
```
Пример:
```cpp
int sum(int a, int b); // объявление функции
int sum(int a, int b) { // определение функции
	return (a + b);
}
```
**Функция** - это именованная последовательность описаний и операторов, выполняющая некоторые законченные действия. Функция может принимать параметры и возвращать результаты. Любая программа на С состоит из функций, одна из которых обязательно `main`. Любая функция должна быть объявлена и определена. Объявление функции должно быть раньше, чем её определение. Оно также называется прототипом, заголовком или сигнатурой функции. Определение функции кроме заголовка содержит тело функции.  
Составные части определения:
1. С помощью необязательного модификатора `[класс]` можно явно задать область видимости функции. Этих модификаторов может быть два: 
	- `extern` - глобальная видимость функции во всех модулях программы, используется по умолчанию
	- `static` - видимость в пределах модуля, в котором определена функция
2. `тип` возвращаемого значения может быть любым, кроме массива и функции, но может быть указателем на массив или функцию. Если функция не возвращает никаких значений, она описывается типом `void` и становится процедурой.
3. Если используется модификатор `extern`, `имя` функции должно быть уникальным.
4. `список параметров` определяет величины, которые следует передать в функцию при её вызове, а также, возможно, результаты, которые функция будет возвращать. Параметры функции перечисляются через запятую.
5. В заголовке функции можно задать список `исключений`, которые эта функция будет косвенно или прямо порождать.
## Локальные и глобальные переменные
Переменные, описанные внутри функции, являются **локальными**, и могут использоваться только в этой функции.  
Переменные, описанные в программе до заголовков функций, называются **глобальными**, и могут использоваться в любой функции этой программы.
**Пример:** программа, считающая сумму чисел
```cpp
#include <iostream>
using namespace std;

int s;
int sum(int a, int b); //сумма 2 целых чисел a и b

int main() {
	int a = 5, b = 7;
	//s = 1000; - так не писать!
	sum(a, b);
	cout << s << endl;
	system("pause");
	return 0;
}

int sum(int a, int b) {
	s = a + b;
	return s;
}
```
## Параметры функции
Механизм параметра является основным способом обмена информацией между вызывающей и выполняющей функциями. Существует три вида передачи параметров в функцию:
- **По значению** (`f(a)`): параметры описываются как обычные переменные. В функцию передаётся значение из места вызова, под которое внутри функции отводится своя ячейка памяти. Фактически, производится копирование значения параметра. Даже если такой параметр внутри функции будет изменён, его "собрат" при вызове останется прежним.
	```cpp
	#include <iostream>
	using namespace std;
	
	int s;
	int f(int a) { 
		a *= 11;
		cout << a << endl;
		return a;
	};
	
	int main() {
		int a = 5;
		f(a);
		cout << a << endl;
		system("pause");
		return 0;
	}
	```
- **По адресу** (`f(*a)`): параметр внутри функции описывается как указатель и из места вызова ему передаётся не значение, а адрес некоторой ячейки памяти. При изменении значения разыменованного указателя, в функции автоматически изменится значение в точке вызова.
	```cpp
	#include <iostream>
	using namespace std;
	
	int s;
	int f(int *a) {
		(*a) *= 11;
		cout << *a << endl;
		return *a;
	};
	
	int main() {
		int a = 5, b = 7;
		int& aaaa = b;
		b *= 2;
		aaaa *= 3;
		cout << b << endl;
		f(&a);
		cout << a << endl;
		system("pause");
		return 0;
	}
	```
- **По ссылке** (`f(&a)`): **ссылочная переменная** - это альтернативное имя некоторой другой переменной того же типа. Ссылочная переменная описывается через `&` и при описании ссылке сразу нужно присвоить некоторое значение, которое в дальнейшем изменить будет нельзя.
	```cpp
	#include <iostream>
	#include <string>
	using namespace std;
	
	void f(int a, int* b, int& c) {
		a = a + (*b) + c;
		*b = a + (*b) + c;
		c = a + (*b) + c;
	};
	
	int main() {
		int a = 1, b = 1, c = 1;
		f(a, &b, c);
		cout << a << ' ' << b << ' ' << c << endl;
		system("pause");
		return 0;
	}
	```
#### Формальные и фактические параметры
Параметры, описанные в заголовке функции, называются **формальными**, так как изначально они никаких значений не несут, и лишь в теле функции формально показывается, что с этими параметрами должна делать функция. Их "собратья" при вызове называются **фактическими**, так как они передают фактические значения формальным параметрам.
**Пример:** пятиугольник задан своими сторонами и диагоналями, как показано на рисунке:  
![Пятиугольник](../Pictures/04_01.%20Пятиугольник.png)  
Найти площадь пятиугольника, используя функцию площади треугольника по 3 сторонам.
```cpp
#include <iostream>
#include <string>
using namespace std;

double geron(double a, double b, double c) {
	double p = (a + b + c) / 2;
	return sqrt(p * (p - a) * (p - b) * (p - c));
};

int main() {
	double a = 5, b = 5, c = 5, d = 5, e = 5, d1 = 7, d2 = 7;
	double s = geron(a, b, d1) + geron(d1, d2, e) + geron(c, d, d2);
	cout << "s=" << s << endl;
	system("pause");
	return 0;
}
```
## Рекурсия
Любую функцию можно вызвать внутри любой другой. Отдельный интерес вызывает обращение к функции внутри самой этой функции. Такое обращение называется **рекурсией**, а функция - **рекурсивной**. 
```cpp
void f() {
	f();
}
```
Чтобы в рекурсивной функции не получилось зацикливания, а точнее переполнения стека, в неё добавляют параметр, который при каждом следующем вызове изменяется, и по достижении некоторого значения рекурсивный вызов прекращается.  
```
f(3) = f(2) * 3 = 6
f(2) = f(1) * 2 = 2
f(1) = f(0) * 1 = 1
f(0) = 1
```
Примеры:
1. Вывод сообщения определенное `n` раз
```cpp
#include <iostream>
#include <string>
using namespace std;

void f(int n) {
	if (n > 0) {
		cout << "UbegAnna!!!";
		f(n - 1);
	}
};

int main() {
	f(5);
	system("pause");
	return 0;
}
```
  2. Вычисление факториала числа `n`
```cpp
#include <iostream>
#include <string>
using namespace std;

int f(int n) {
	if (n == 0) return 1;
	else return f(n - 1) * n;
};

int main() {
	cout << f(5) << endl;
	system("pause");
	return 0;
}
```
Рекурсивной может быть не только функция, но и процедура, возвращающая результат через параметр.
## Передача в функцию массивов
#### Одномерные массивы
В качестве параметра используется указатель на первый элемент массива, но функция сама по себе количество элементов не знает. Поэтому вторым параметром передаётся размер массива.
```cpp
#include <iostream>
using namespace std;

int sum(int* a, int n) {
	int s = 0;
	for (int i = 0; i < n; i++)
		s += a[i];
	return s;
};

int main() {
	const int n = 5;
	int a[n] = { 1, 2, 3, 2, 1 };
	cout << sum(a, n) << endl;
	system("pause");
	return 0;
}
```
#### Двумерные массивы
В случае двумерного массива есть разница при передаче динамических и статических массивов.  
В случае динамических массивов, массив передаётся через двойной указатель с указанием двух дополнительных параметров - числа строк и числа столбцов.  
```cpp
#include <iostream>
#include <string>
using namespace std;

int sum(int** a, int n1, int n2) {
	int s = 0;
	for (int i = 0; i < n1; i++)
		for (int j = 0; j < n2; j++)
			s += a[i][j];
	return s;
};

int main() {
	srand(time(0));
	int n1 = 3, n2 = 3;
	int** a = new int* [n1];
	for (int i = 0; i < n1; i++)
		a[i] = new int[n2];
	for (int i = 0; i < n1; i++) {
		for (int j = 0; j < n2; j++)
			a[i][j] = rand() / 100.0 - 50;
	}
	for (int i = 0; i < n1; i++) {
		for (int j = 0; j < n2; j++)
			cout << a[i][j] << "  ";
		cout << endl;
	}
	cout << sum(a, n1, n2) << endl;
	system("pause");
	return 0;
}
```
Статический двумерный массив может быть передан только через указатель, но в этом случае он будет рассматриваться в функции как одномерный массив с количеством элементов `n1 * n2`, и доступ к элементам массива по двойному индексу (`[i][j]`) невозможен. Но, поскольку элементы хранятся один за другим, можно организовать пересчёт индексов из двумерного в одномерный массив:
```
a[0][1] = a[0 * 2 + 1] = 1
a[1][0] = a[1 * 2 + 0] = 2
```
  
```cpp
#include <iostream>
#include <string>
using namespace std;

int sum(int* a, int n1, int n2) {
	int s = 0;
	for (int i = 0; i < n1; i++)
		for (int j = 0; j < n2; j++)
			s += a[i * n2 + j];
	return s;
};

int main() {
	const int n1 = 3, n2 = 3;
	int a[n1][n2] = { {1, 2, 1}, {3, 4, 1}, {5, 6, 1} };
	
	
	cout << sum(&a[0][0], n1, n2) << endl;
	system("pause");
	return 0;
}
```
## Параметры по умолчанию
Чтобы упростить вызов функции, в её заголовке можно указать значения некоторых параметров по умолчанию. Эти параметры должны быть последними в списке и могут опускаться при вызове функции. Если опущен один, то должны быть опущены и остальные.
```cpp
int sum(int a = 2, int b = 5) {

}
```
## Заголовочные файлы
**Заголовочный файл** - это файл, чаще всего содержащий заголовки (прототипы, сигнатуры) некоторых функций. В нём можно также описать и тело каждой функции. Но, как правило, описание отделяется от заголовка и выносится вообще в другой файл. Для подключения созданного заголовочного файла используется директива `#include`, но так как созданный заголовочный файл обычно находится в той же папке, что и файл основной программы, то его имя берётся в кавычки.  
Файл `Header.h`:
```cpp
#pragma once
//Сумма элементов двумерного массива a размером n1xn2
int sum(int* a, int n1 = 3, int n2 = 2);
//Ввод элементов двумерного массива a размером n1xn2
void vvod(int* a, int n1 = 3, int n2 = 2);
```
Файл `Source.cpp`:
```cpp
#include <iostream>
#include "Header.h"
using namespace std;

int main() {
	const int n1 = 3, n2 = 3;
	int a[n1][n2] = { {1,2,1}, {3, 4, 1}, {5, 6, 1} };

	cout << sum(&a[0][0], 3, 2) << endl;
	system("pause");
	return 0;
}
```
## Перегрузка функции
Описание двух и более функций с одинаковым именем, но разным по количеству или типу набором параметров называется **перегрузкой функции**. Компилятор определяет какую из функций выбрать по набору фактических параметров при вызове.
**Пример:** программа, находящая периметры разных фигур (перегрузка по количеству параметров):
```cpp
#include <iostream>
using namespace std;

double perimetr(double a) {
	return 4 * a;
}

double perimetr(double a, double b) {
	return 2 * (a + b);
}

double perimetr(double a, double b, double c) {
	return a + b + c;
}

int main() {
	double a, b, c;
	cout << "Enter a: " << endl;
	cin >> a;
	cout << perimetr(a) << endl;
	cout << "Enter a, b: " << endl;
	cin >> a >> b;
	cout << perimetr(a, b) << endl;
	cout << "Enter a, b, c: " << endl;
	cin >> a >> b >> c;
	cout << perimetr(a, b, c) << endl;
	system("pause");
	return 0;
}
```
**Пример:** перегрузка по типу параметров
```cpp
#include <iostream>
using namespace std;

void f(double a, double b) {
	cout << "double";
}

void f(int a, int b) {
	cout << "int";
}

void f(double a, int b) {
	cout << "int";
}

void f(int a, double b) {
	cout << "int";
}

int main() {
	int a = 0, b = 0;
	f(a, b);
}
```
