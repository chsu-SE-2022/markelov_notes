В ходе работы той или иной части программы может возникнуть ситуация, вызывающая некоторую ошибку выполнения программы. Например, деление на ноль, отсутствие файла на диске и т. д. Подобного рода ошибки можно предусмотреть заранее, организовав их обработку внутри блока, где ошибка может возникнуть сразу при написании кода.  
Пример без использования механизма исключений:
```cpp
#include <iostream>
using namespace std;

double f(int* a, int n) {
	int s = 0;
	for (int i = 0; i < n; i++)
		s += a[i];
	if (a[0] == 0) return 0;
	else return ((double)s) / a[0];
}

int main() {
	const int n = 1;
	int a[3] = { 0, 2, 3 };
	cout << f(a, n) << endl;
	system("pause");
	return 0;
}
```
Для разрешения подобного рода ситуаций в языке С создан механизм обработки исключений с помощью 3 служебных слов: `try`, `catch` и `throw`:
- `try { операторы }` - позволяет в любом месте кода программы выделить контролируемый блок, в котором может произойти исключение 
- `catch(тип исключения) { операторы }` - т. н. обработчик исключения, который ставится сразу после блока `try`. В скобках указывается тип исключения, операторы, действия, которые нужно выполнить при возникновении исключения 
- `throw` - когда выполняется такой оператор, то с помощью выражения, стоящего после `throw`, формируется специальный объект, называемый исключением. Тип объекта определяется типом выражения после `throw`. Как только выполнился оператор `throw`, управление передаётся в первый блок `catch`, стоящий после `try`.
  
Один и тот же блок может возвращать несколько исключений. При этом выражения, выбрасывающие исключение, могут быть разных типов. В этом случае после `try` может быть несколько блоков `catch`, каждый для своего типа.
```cpp
#include <iostream>
using namespace std;

double f(int* a, int n) {
	int s = 0;
	for (int i = 0; i < n; i++)
		s += a[i];
	if (a[0] == 0) throw 0;
	if (s / a[0] == 666) throw "Devil's number!!!!!!!";
	else return ((double)s) / a[0];
}

int main() {
	const int n = 1;
	int a[3] = { 1,1,664 };
	int res;
	try {
		res = f(a, n);
		cout << res << endl;
	}
	catch (int ex) {
		if (ex == 0) res=1;
	}
	catch (char* ex) {
		cout << ex << endl;
	}
	catch (...) {
		cout << "Something wrong" << endl;
	}
	system("pause");
	return 0;
}
```
В C++ существует иерархия классов исключений:  
![Типы исключений](../Pictures/06_01.%20Типы%20исключений.png)  
Класс `exception` является базовым классом родительским классом для всех классов исключений. У него имеется метод `what()`, который возвращает строку информации о типе исключения.  
`runtime_error` - общий тип исключений, возникающий в процессе выполнения программы. От него наследуются три класса:
- `range_error` - результат выходит из допустимого диапазона
- `overflow_error` - результат превышает допустимый диапазон
- `underflow_error` - результат имеет недопустимое отрицательное значение