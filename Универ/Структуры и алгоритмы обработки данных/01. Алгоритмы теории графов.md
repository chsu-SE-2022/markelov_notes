## Обход графа в ширину (волновой обход)
*Задача:* лабиринт состоит из множества комнат одинакового размера. Некоторые из комнат соединены дверями. Определить, можно ли пройти из комнаты $A$ в комнату $B$, и если да, за какое минимальное количество перемещений.  
Математической моделью данной задачи является неориентированный граф. Вершины графа - комнаты, ребра - двери.   
Проще всего задача решается обходом графа в ширину, начиная с вершины $A$.  
Алгоритм:
1. Присваиваем вершине $A$ метку $0$
2. Всем вершинам, смежным с вершиной $A$, присваивается метка $1$
3. Процесс продолжается следующим образом: всем непомеченным вершинам, смежным с единицами, присваивается метка $2$, смежным с двойками - метка $3$ и т. д.
4. Если помечена вершина $B$, алгоритм завершается, метка вершины $B$ и есть минимальное количество шагов от $A$ до $B$
5. Если на некотором шаге ни одна вершина не получила новую метку, а вершина $B$ так и не помечена, значит пути из вершины $A$ в вершину $B$ не существует  

![[Pasted image 20240207201014.png]]  
Если необходимо найти не только количество шагов, но и путь, будем двигаться от вершины $B$ к одной из смежных вершин с меткой на 1 меньшей данной вершины  
```java
public int makeWave(int a, int b) {
int path[] = new int[size+1];
for (int i = 1; i <= size; i++) path[i] = -1;
path[a] = 0;
int num = 1, i = 1;
boolean f = false, f1 = true;
do {
while (i <= size && path[i] != num-1) i++;
if (i <= size) {
f = true;
for (int j = 1; j <= size; j++)
if (gr[i][j] == 1 && path[j] == -1) {
path[j] = num;
}
i++;
}
else {
if (f) {
i = 1; f = false; 
num++;
}
else f1 = false;
}
}
while (f1);
return path[b];
}
```
Обход в ширину фактически позволяет найти путь минимальной длины от вершины $A$ к любой другой вершине в произвольном невзвешенном графе $G$. Если ребра (дуги) графа имеют вес, обход в ширину данную задачу не решает
## Алгоритм Дейкстры
Имеется произвольный граф, каждому ребру (дуге) которого присвоена некоторая неотрицательная стоимость. Требуется найти путь минимальной стоимости из вершины $A$ в вершину $B$.  
Алгоритм:  
1. Присвоим вершине $A$ метку $0$, объявив метку постоянной. Остальным вершинам присвоим метку $+∞$, считая эти метки временными
2. Берем вершину, получившую постоянную метку на предыдущем шаге и для каждой смежной с ней вершины $j$ пересчитываем временную метку по формуле $metka[j] = min(metka[j], metka[i]+gr[i][j])$
3. Из всех временных меток выбираем минимальную, делаем ее постоянной, если она не искомая, идем на пункт 2, иначе на пункт 4
4. Постоянная метка вершины $B$ и есть минимальная стоимость искомого пути. Сам путь можно найти 2 способами - либо считать путь от $B$ к $A$, либо заранее записывать метки  

![[Pasted image 20240207201356.png]]  
```java
public class Deikstra {
int[][] gr;
int size;
class Metka{
int volume, type;
}
Metka[] m;
}
public int findPath(int a, int b) {
m[a].volume = 0;
m[a].type = 1;
int i = a;
for (int j = 1; j <= size; j++)
if (j!=i) {
m[j].volume = Integer.MAX_VALUE;
m[j].type = 0;
}
while (i != b) {
for (int j = 1; j <= size; j++)
if (gr[i][j] != 0 && m[j].type == 0)
if (m[j].volume > m[i].volume + gr[i][j]) {
m[j].volume = m[i].volume + gr[i][j];
}
int min = Integer.MAX_VALUE, nmin = 0;
for (int j = 1; j <= size; j++)
if (m[j].volume < min && m[j].type == 0) {
min = m[j].volume; 
nmin = j;
}
m[nmin].type = 1;
i = nmin;
}
return m[b].volume;
}
```
