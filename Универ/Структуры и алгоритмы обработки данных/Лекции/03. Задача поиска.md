Имеется последовательность объектов (записей). Требуется отыскать объект по некоторому значению ключа, либо сказать, что такого объекта нет.
## Последовательный поиск
Все элементы последовательности просматриваются один за другим, пока искомый не будет найден или не будет просмотрена вся последовательность. Сложность - $O(n)$.  
```cpp
#include <iostream>
#include <fstream>
using namespace std;

int straightSearch(int* m, int n, int key) {
	int i = 0;
	while (i < n && m[i] != key) i++;
	if (i < n) return i;
	else return -1;
}

void main() {
	const int n = 8;
	int a[n] = { 8, 4, 55, 66, 4, 123, 12, 666 };
	cout << straightSearch(a, n, 4) << ' ';
	cout << endl;
	system("pause");
}
```
В цикле **while** первое условие ($i < n$) к поиску элемента никакого отношения не имеет. Чтобы ее избежать, опишем массив на 1 элемент больше, чем его реальный размер, и при каждом поиске элемента на последнее ($n$-ное) место в массиве будем ставить искомый ключ.
```cpp
#include <iostream>
#include <fstream>
using namespace std;

int straightSearch(int* m, int n, int key) {
	int i = 0;
	m[n] = key;
	while (m[i] != key) i++;
	if (i < n) return i;
	else return -1;
}

void main() {
	const int n = 8;
	int a[n + 1] = { 8, 4, 55, 66, 4, 123, 12, 666, 0 };
	cout << straightSearch(a, n, 4) << ' ';
	cout << endl;
	system("pause");
}
```
## Бинарный поиск
Данный поиск проводится на отсортированной последовательности так называемым методом половинного деления. Находим элемент, находящийся в середине массива (с индексом $n/2$) и сравниваем искомый ключ с данным элементом. Если ключ равен - поиск закончен. Если меньше среднего - продолжим поиск в левой половине, если больше - в правой. Сложность такого метода - $O(log_2n)$.
```cpp
#include <iostream>
#include <fstream>
using namespace std;

int binarySearch(int* m, int n, int key) {
	int left = 0, right = n - 1, i = (left + right) / 2;
	while (left <= right && key != m[i]) {
		if (key < m[i]) right = i - 1;
		if (key > m[i]) left = i + 1;
		i = (left + right) / 2;
	}
	if (left <= right) return i;
	else return -1;
}

void main() {
	const int n = 8;
	int a[n + 1] = { 4, 4, 8, 12, 55, 66, 123, 666 };
	cout << binarySearch(a, n, 4) << ' ';
	cout << endl;
	system("pause");
}
```
## Дерево поиска
Первый элемент последовательности становится корнем бинарного дерева. Каждый следующий добавляется по правилу: если элемент меньше корня - он идет в левое поддерево, если больше - в правое, и далее рекурсивно.  
![[03_01. Дерево поиска.png]]  
Поиск по такому дереву происходит сравнением исходного ключа со значением в узле и дальнейшим проходом налево либо направо в зависимости от того, меньше искомый ключ значения в узле или больше.  
Если дерево поиска получилось сбалансированное (разность высот левого и правого поддеревьев у любого узла отличаются не более чем на 1), то сложность поиска по нему - $O(log_2n)$. В худшем случае дерево может выродится в линейный список и сложность поиска будет $O(n)$.  
*Код не закончен*
```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

struct node {
	string word;
	int k;
	node* left;
	node* right;
};

void insert(node*& root, string word) {
	if (root == NULL) {
		root = new node;
		root->word = word;
		root->k = 1;
		root->left = NULL;
		root->right = NULL;
	}
	else if (word < root->word) insert(root->left, word);
	else if (word > root->word) insert(root->right, word);
	else root->k++;
}

void printTree(node* root) {
	if (root != NULL) {
		printTree(root->left);
		cout << root->word << "-" << root->k << endl;
		printTree(root->right);
}

void main() {
	const int n = 8;
	int a[n + 1] = { 8, 4, 55, 66, 4, 123, 12, 666, 0 };
	cout <<  << ' ';
	cout << endl;
	system("pause");
}
```