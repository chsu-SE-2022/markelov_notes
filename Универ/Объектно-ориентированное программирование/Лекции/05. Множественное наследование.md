При множественном наследовании производный класс создается от более чем одного базового класса.
![[05_01. Пример иерархии классов со множественным наследованием.png]]  
![[05_02. Иерархия классов транспортных средств.png]]  
Компилятор организует наследование на основе ориентированного ациклического графа:  
![[05_03. Ациклический граф.png]]  
```
ТС::назем::ПК
ТС::водн::ПК
ТС::возд::ПК
```
![[05_04. Иерархия классов person и worker.png]]  
```cpp
class person_i {
public:
	virtual void print() = 0;
};

class person {
public:
	void print();
protected:
	char name[50];
};

class student : virtual public person {
public:
	void print();
	float S();
protected:
	int N;
	float R;
};

class worker : virtual public person {
public:
	void print();
	float Z();
protected:
	int N_tab;
	int K;
};

class student_worker : public student, public worker {
public:
	void print();
private:
	int t;  //учебный отпуск
};

int main() {
	person a;
	student s;
	worker w;
	student_worker d;
}
```
1. В порядке объявления инициализируются базовые классы
2. Инициализируются элементы классов в списке инициализаторов
3. Выполняется тело конструктора
  
Виртуальные базовые классы создаются до того, как будут созданы невиртуальные базовые классы.  
![[05_05. Иерархия классов со множественным наследованием.png]]  
## Реализация наследования
**Закрытое наследование** имеет своей целью только повышение степени повторного использования кода  
![[05_06. Разные виды наследования.png]]  
Шаблоны классов и функций легче проектировать. Программа быстрее выполняется, если мы используем шаблоны.  
```cpp
class vector { //БК
public:
vector();
vector(void* d, int n);
vector(const vector& m);
void print() const;
void input(void* d);
void* find(void* d);
};

protected:
void* p;
int k;
```