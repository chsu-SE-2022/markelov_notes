**Многопоточность** - это:
- одновременное выполнение нескольких действий (например, отрисовка пользовательского интерфейса и передача файлов по сети)
- ускорение вычислений (при наличии нескольких вычислительных ядер)
  
**Закон Амдала**: $S(N)=\frac{1}{(1-P)+\frac{P}{N}}$, где:
- $S$ - ускорение (speedup)
- $P$ - доля вычислений, которые возможно распараллелить
- $N$ - количество вычислительных ядер
  
Доступ к разделяемому ресурсу:
- Блокировка (mutual exclusion)
- Неблокирующий доступ:
	- Lock-free - гарантированный прогресс приложения
	- Wait-free - гарантированный прогресс каждого потока (каждый поток завершает выполнение любой операции за конечное число шагов)
  
Потоки представлены экземплярами класса `java.lang.Thread`:
- `String getName()`
- `Long getId()`
- `boolean isDaemon()`
- `StackTraceElement[] getStackTrace()`
- `ThreadGroup getThreadGroup()`
#### Создание потоков
Создание потока подкласса `Thread`:
```java
Thread thread = new Thread() {
	@Override
	public void run() {
		//...
	}
}
```
  
```java
import.java.util.*;

public class Main {
	public static void main(String[] args) {
		Thread th1 = new Thread() {
			public void run() {
				System.out.println(getName());
			}
		};
		Thread th2 = new Thread() {
			public void run() {
				System.out.println(getName());
			}
		};
		th1.start();
		th2.start();
		System.out.println("Main thread");
	}
}
```
  
```java
import.java.util.*;

public class Main {
	private static class MyThread implements Runnable {
		public void run() {
			System.out.println(Thread.currentThread().getName());
		}
	}
	public static void main(String[] args) {
		for (int i = 1; i <= 10; i++)
			new Thread(new myThread()).start();
		th1.start();
		th2.start();
		System.out.println("Main thread");
	}
}
```
#### Управление потоками
Управление потоками класса `java.lang.Thread`:
- `start()`
- `sleep()`
- `join()`
- `interrupt()`
- `stop()`
```java
import.java.util.*;

public class Main {
	private static class MyThread implements Runnable {
		public void run() {
			try {
				//Thread.sleep(1000);
				System.out.println(Thread.currentThread());
			}
			catch (InterruptedExceprion ex) {}
		}
	}
	public static void main(String[] args) {
		for (int i = 1; i <= 10; i++) {
			Thread th = new Thread(new myThread());
			th.start();
			th.join();
		}
		System.out.println("Main thread");
	}
}
```
#### Жизненный цикл потока
- **Создание объекта** `Thread`
- **Запуск** - `thread.start()`
- **Работа** - выполняется метод `run()`,  `thread.isAlive() == true`
- **Завершение** - метод `run()` закончился или бросил исключение
- **Завершенный поток нельзя перезапустить**
## Синхронизация
- **Взаимное исключение** - пока один поток что-то делает, другие не могут ему помешать
- **Ожидание и уведомление** - поток ожидает уведомлений от других потоков
#### Ключевое слово `synchronized`
- Синхронизированный метод:
	```java
	public synchronized void doSomething() {
		//...
	}
	```
- Синхронизированный блок внутри метода:
	```java
	public void doSomething() {
		synchronized(obj) {
			//...
		}
	}
	```