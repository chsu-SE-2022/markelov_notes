**Spring Framework** - облегченная платформа для построения enterprise-приложений на Java:
- Можно применять к любому Java-приложению, не привязана к web
- Облегченная - не размер дистрибутива, а степень воздействия на код
- Модульная структура (IoC, web, Data Access, Messaging, ...)
## Основа Spring
Ядро Spring Framework основано на принципе **инверсии управления (Inversion of Control - IoC)**, когда создание и управление зависимостями между компонентами становятся внешними.  
Мартин Фаулер назвал процесс внедрения зависимостей во время выполнения, приводящее к инверсии **Dependency Injection - DI**.
Реализация DI в Spring основана на 2 концепциях:
- JavaBean
- Интерфейсы
  
В Spring любой управляемый ресурс - это **bean**.  
С помощью интерфейсов можно получить максимальную отдачу от DI: бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.  
Конфигурирование через XML или классы Java, или аннотации в коде, или через Groovy.  
Основные преимущества DI:
- Сокращение объема связующего кода
- Упрощенная конфигурация приложения
- Возможность управления общими зависимостями в единственном репозитории
- Улучшенная возможность тестирования
  
Широчайший набор средств и инструментов:
- АОП (аспектно-ориентированное программирование)
- SpEL (Spring Expression Language)
- Валидация - проверка достоверности
- Доступ к данным реляционных БД, NoSQL, графовые и документные БД
- Управление транзакциями
- MVC на web-уровне
- Поддержка WebSocket
## Модули Spring
![Модули Spring](../Pictures/10_01.%20Модули%20Spring.png)  
## Три кита Spring-приложений
1. **Core** обеспечивает ключевые части фреймворка, включая свойства IoC и DI.  
2. **Beans** - это классы, созданием экземпляров которых и установкой в них зависимостей управляет контейнер фреймворка Spring.  
3. **Context** построен на основе Beans и Core и позволяет получать доступ к любому объекту, который определен в настройках. Ключевым элементов модуля Context является интерфейс `ApplicationContext`.
## Apache Maven
**Maven** - слово на идише, означающее "накопитель знаний".  
Инструмент, который можно использовать для созданий и управления любым проектом на основе Java:
- Упрощение процесса сборки
- Обеспечение единой системы сборки
- Предоставление качественной информации о проекте
- Поощрение лучших практик разработки
## Inversion of Control (IoC) - инверсия управления
Ядро Spring Framework основано на принципе **инверсии управления (Inversion of Control - IoC)**, когда создание и управление зависимостями между компонентами становятся внешними.
#### Проблема
```java
class ClassicalMusic {
	//...
}

class MusicPlayer {
	private ClassicalMusic cimusic;
	
	public void PlayMusic() {
	clmusic = newClassicalMusic();
	//...
	}
}
```
Сильная зависимость - класс `MusicPlayer` сильно зависит от класса `ClassicalMusic`.
#### Первое решение - интерфейс
```java
Interface Music {
	//...
}

class ClassicalMusic implements Music {
	//...
}

class RockMusic implements Music {
	//...
}

class MusicPlayer {
	private Music music;
	
	public void PlayMusic() {
		music = new ClassicalMusic();
		//...
		music = new RockMusic();
		//...
	}
}
```
Слабая зависимость - все классы создаются вручную внутри `MusicPlayer`.
#### Второе решение - beans
```java
Interface Music {
	//...
}

class ClassicalMusic implements Music {
	//...
}

class RockMusic implements Music {
	//...
}

class MusicPlayer {
	private Music music;
	
	public void PlayMusic() {
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
		
		music = context.getBean("classicMusic", ClassicalMusic.class);
		//...
		music = context.getBean("rockMusic", RockMusic.class);
	}
}
```
`MusicPlayer` сам создает свои зависимости.  
#### Inversion of Control
```java
Interface Music {
	//...
}

class ClassicalMusic implements Music {
	//...
}

class RockMusic implements Music {
	//...
}

class MusicPlayer {
	private Music music;
	
	public MusicPlayer(Music music) {
		this.music = music;
	}
	
	public void playMusic() {
		//...
	}
}
```
Сущность не сама создает свои зависимости, зависимости поставляются извне.  
Объект, который мы внедряем в `MusicPlayer` необходимо где-то создать.
```java
class Play {
	public static void main(String[] args) {
		MusicPlayer mp = new MusicPlayer(new RockMusic());
	}
}
```
Внедрение зависимостей - **Dependency Injection**.
```java
public class TestSpring {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("appContext.xml");
		Music music = context.getBean("musicBean", music.class);
		MusicPlayer musicPlayer = new MusicPlayer(music);
		musicPlayer.playMusic();
		context.close();
	}
}
```
## Dependency Injection (DI) - внедрение зависимостей
**Внедрение зависимости (DI - Dependency Injection)** - это процесс предоставления программному компоненту внешней зависимости. Согласно принципу единой обязанности, объект передает "заботу" о построении нужных ему зависимостей внешнему механизму, который специально для этого предназначен:
- Нулевое воздействие на код
- Легкость тестирования без привязки к контейнеру
#### Внедрение зависимостей с помощью конструктора
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic">
</bean>

<bean id = "musicPlayer"
	class = "ru.kmp.MusicPlayer">
	<constructor.arg ref = "musicBean"/>
</bean>
```
  
```java
public class TestSpring {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("appContext.xml");
		MusicPlayer musicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
		musicPlayer.playMusic();
		context.close();
	}
}
```
#### Внедрение зависимостей с помощью метода `setter`
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic">
</bean>

<bean id = "musicPlayer"
	class = "ru.kmp.MusicPlayer">
	<property name = "music" ref = "musicBean"/>
	
	<property name = "name" value = "Super Player"/>
	<property name = "volume" value = "80"/>
</bean>
```
  
```xml
<bean id = "musicBean"
	class = "ru.kmp.ClassicalMusic">
	init-method = "doMyInit"
	destroy-method = "doMyDestroy"
</bean>

<bean id = "musicPlayer"
	class = "ru.kmp.MusicPlayer">
	<property name = "music" ref = "musicBean"/>
	
	<property name = "name" value = "${musicPlayer.name}"/>
	<property name = "volume" value = "${musicPlayer.volume}"/>
</bean>
```
## Scope
**Scope** задает то, как Spring будет создавать бины:
- `singleton`
- `prototype`
- `request`
- `session`
- `global-session`
- `websocket`
  
```xml
<bean id = "musicBean"
	class = "ru.kmp.MusicPlayer" scope = "prototype">
	<property name = "music" ref = "musicBean"/>
	
	<property name = "name" value = "Super Player"/>
	<property name = "volume" value = "80"/>	
</bean>
```
## Жизненный цикл бина (Bean Lifecycle)
![Жизненный цикл бина](../Pictures/10_02.%20Жизненный%20цикл%20бина.png)