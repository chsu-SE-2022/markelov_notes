Имеется последовательность объектов (записей). Требуется отыскать объект по некоторому значению ключа, либо сказать, что такого объекта нет.
## Последовательный поиск
Все элементы последовательности просматриваются один за другим, пока искомый не будет найден или не будет просмотрена вся последовательность. Сложность - $O(n)$.  
```cpp
#include <iostream>
#include <fstream>
using namespace std;

int straightSearch(int* m, int n, int key) {
	int i = 0;
	while (i < n && m[i] != key) i++;
	if (i < n) return i;
	else return -1;
}

void main() {
	const int n = 8;
	int a[n] = { 10, 4, 55, 66, 4, 123, 12, 666 };
	cout << straightSearch(a, n, 4) << ' ';
	cout << endl;
	system("pause");
}
```
В цикле **while** 1 условие ($i<n$) к поиску элемента никакого отношения не имеет. Чтобы ее избежать, опишем массив на 1 элемент больше, чем его реальный размер, и при каждом поиске элемента на последнее ($n$-ное) место в массиве будем ставить искомый ключ.
```cpp
#include <iostream>
#include <fstream>
using namespace std;

int straightSearch(int* m, int n, int key) {
	int i = 0;
	m[n] = key;
	while (m[i] != key) i++;
	if (i < n) return i;
	else return -1;
}

void main() {
	const int n = 8;
	int a[n + 1] = { 10, 4, 55, 66, 4, 123, 12, 666, 0 };
	cout << straightSearch(a, n, 4) << ' ';
	cout << endl;
	system("pause");
}
```
## Бинарный поиск
Данный поиск проводится на отсортированной последовательности так называемым методом половинного деления. Находим элемент, находящийся в середине массива (с индексом $n/2$) и сравниваем искомый ключ с данным элементом. Если ключ равен - поиск закончен. Если меньше среднего - продолжим поиск в левой половине, если больше - в правой. Сложность такого метода - $O(log_2n)$.
```cpp
#include <iostream>
#include <fstream>
using namespace std;

int binarySearch(int* m, int n, int key) {
	int left = 0, right = n - 1, i = (left + right) / 2;
	while (left <= right && key != m[i]) {
		if (key < m[i]) right = i - 1;
		if (key > m[i]) left = i + 1;
		i = (left + right) / 2;
	}
	if (left <= right) return i;
	else return -1;
}

void main() {
	const int n = 8;
	int a[n + 1] = { 4, 4, 8, 12, 55, 66, 123, 666 };
	cout << binarySearch(a, n, 4) << ' ';
	cout << endl;
	system("pause");
}
```
