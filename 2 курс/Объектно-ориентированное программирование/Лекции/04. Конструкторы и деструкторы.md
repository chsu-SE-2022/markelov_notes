Для правильной работы с объектами необходимы специальные компонентные функции, отвечающие за создание и уничтожение объектов - **конструкторы** и **деструкторы**.  
Характеристика конструктора:
1. Назначение конструктора - создание объектов: выделение памяти для объекта и запись начального значения (определение и инициализация)
2. Имя конструктора совпадает с именем класса
3. Конструктор не имеет возвращаемого типа, а это значит, что в теле конструктора не используется оператор **return**
4. Конструкторов может быть много, т. е. они могут быть перегружены
5. Конструкторы могут иметь параметры (а могут и не иметь)
6. Конструкторы не наследуются
7. Конструкторы не могут быть виртуальными, а значит к ним не применяется механизм замещения
8. Конструкторы бывают 3 типов:
	- Конструкторы для инициализации
	- Конструкторы по умолчанию
	- Копирующие конструкторы
9. Конструктор вызывается автоматически, когда объявляется объект, когда в функцию передаются параметры по значению, когда функция возвращает объект класса
10. Конструкторы могут вызываться принудительно
11. Конструкторы могут использоваться как преобразователи типов данных
12. Конструкторы могут иметь инициализаторы
  
Характеристика деструкторов:
1. Назначение деструктора - уничтожение объекта: освобождение ранее выделенной памяти
2. Имя деструктора тоже совпадает с именем класса, только перед ним используется значок "**~**" (тильда)
3. Деструктор не имеет возвращаемого типа, а значит в теле не используется оператор **return**
4. Деструктор всегда один, перегрузка не применяется
5. Параметров деструктор не имеет
6. Деструкторы не наследуются
7. Деструкторы могут быть виртуальными
8. Деструкторы вызываются автоматически, когда объект выходит за пределы области элемента, когда при уничтожении сложного объекта сначала уничтожаются просты, из которых он состоит
9. Деструктор можно вызвать принудительно
```cpp
class pixel {
public:
	pixel(); // конструктор по умолчанию
	pixel(int a, int b, char* c);
	pixel(const pixel& m); // копирующий конструктор
	pixel(int a);
	pixel(char* c);
	pixel(int a, int b);
	pixel(int a, char* c);
	
	~pixel() {
		delete[] color;
	}
	
	void input(int a, int b, char* c);
	void print() const;
	
private:
	int x, y;
	char* color;
};

pixel::pixel() {
	x = 0;
	y = 0;
	color = "red";
}

pixel::pixel(int a, int b, char* c) {
	x = a;
	y = b;
	color = new char[strlen(c) + 1];
	strcpy(color, c);
}

pixel::pixel(int a) {
	x = a;
	y = 3;
	color = "green";
}

pixel::pixel(char* c) {
	x = y = 10;
	color = new char[strlen(c) + 1];
	strcpy(color, c);
}

pixel::pixel(const pixel &m) {
	x = m.x;
	y = m.y;
	color = new char[strlen(m.color) + 1];
	strcpy(color, m.color);
}

pixel t1, t2(3, 4, "green"), t3(11, "red"), t4(t2);

void f1(pixel t);
pixel f2();
t1.print();
```
![Результат работы программы](../Pictures/04_01.%20Результат%20работы%20программы.png)  
**Копирующий конструктор** всегда должен быть в классе, если хотя бы один из элементов класса - указатель.  
**Конструктор по умолчанию** имеет специальное обозначение для создания массивов объектов.  
**Конструктор с одним параметром** является функцией преобразования типов данных.
## Инициализаторы конструктора
```cpp
class pixel {
private:
	int x, y;
	char* color;
	int& m;
};

pixel::pixel(int a, int b, char* c) : x(a), y(b), m(d) {
	color = new char[strlen(c) + 1];
	strcpy(color, c);
	y = b;
}
```
  
```cpp
class pixel {
public:
	void set_x(int a);
	void set_y(int b);
	void set_color(char* c);
	int get_x() const;
	int get_y() const;
	char* get_color() const;
	
private:
	int x, y;
	char* color;
};

void pixel::set_color(char* c) {
	delete[] color;
	color = new char[strlen(c) + 1];
	strcpy(color, c);
}

int pixel::get_x() const {
	return x;
}

void pixel::set_x(int a) {
	x = a;
}

pixel& copy(const pixel& m); // t2.copy(t1), t1.copy(t2)

pixel& pixel::copy(const pixel& m) {
	if (this != &m) {
		x = m.x;
		y = m.y;
		delete[] color;
		color = new char[strlen(m.color) + 1];
		strcpy(color, m.color);
	}
	return (*this);
}
t2.copy(t1);
```