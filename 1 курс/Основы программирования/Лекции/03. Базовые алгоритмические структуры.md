В теории алгоритмов было доказано, что алгоритмы любой степени сложности могут быть получены с помощью комбинации 3 базовых алгоритмических структур:
1. Следование  
	![Следование](../Pictures/03_01.%20Следование.png)
2. Ветвление
	- Полное  
		![Полное ветвление](../Pictures/03_02.%20Полное%20ветвление.png)
	- Неполное  
		![Неполное ветвление](../Pictures/03_03.%20Неполное%20ветвление.png)
3. Циклы
	- Со счетчиком  
		![Цикл со счетчиком](../Pictures/03_04.%20Цикл%20со%20счетчиком.png)
	- С предусловием  
		![Цикл с предусловием](../Pictures/03_05.%20Цикл%20с%20предусловием.png)
	- С постусловием  
		![Цикл с постусловием](../Pictures/03_06.%20Цикл%20с%20постусловием.png)
## Условный оператор `if`
```cpp
if (выражение) оператор_1;
[else оператор_2];
```
Если логическое выражение истинно, выполняется `оператор_1`, если ложно - `оператор_2`.  
Пример:
```cpp
#include <iostream>
using namespace std;

int main() {
	int a = 56, b = 3;
	if (a > b) cout << a << endl;
	else cout << b << endl;
	system("pause");
	return 0;
}
```
**Задача:** даны 3 целых числа. Найти максимальное.  
**Решение 1:**
```cpp
int a = 56, b = 113, c = 111;
if (a > b)
	if (a > c) cout << a << endl;
	else cout << c << endl;
else
	if (b > c) cout << b << endl;
	else cout << c << endl;
```
**Решение 2:**
```cpp
int a = 56, b = 113, c = 111;
if (a >= b && a >= c) cout << a << endl;
else if (b >= a && b >= c) cout << b << endl;
else cout << c << endl;
```
**Решение 3:**
```cpp
int a = 56, b = 113, c = 111;
int max = a;
if (max < b) max = b;
if (max < c) max = c;
cout << max << endl;
```
В случае истинности или ложности логического выражения всегда выполняется только один оператор. Если нужно выполнить несколько операторов, они объединяются в 1 блок с помощью фигурных операторных скобок (`{}`). Если переменная описана внутри некоторого блока, ее область действия и видимости ограничена рамками этого блока. За пределами блока такой переменной просто не существует.  
**Пример 1:** программа, находящая корни квадратного уравнения (`a ≠ 0`):
```cpp
int main() {
	double a = 1, b = 1, c = -1, x1, x2;
	double d = b * b - 4 * a * c;
	if (d >= 0) {
		x1 = (-b + sqrt(d)) / (2 * a);
		x2 = (-b - sqrt(d)) / (2 * a);
		cout << "x1 = " << x1 << endl;
		cout << "x2 = " << x1 << endl;
	}
	else cout << "No real roots" << endl;
}
```
**Пример 2:** по номеру дня недели вывести его название:
```cpp
int main() {
	int n;
	cout << "n = "; cin >> n;
	if (n == 1) cout << "Monday" << endl; 
	else if (n == 2) cout << "Tuesday" << endl; 
	else if (n == 3) cout << "Wednesday" << endl; 
	else if (n == 4) cout << "Thursday" << endl; 
	else if (n == 5) cout << "Friday" << endl; 
	else if (n == 6) cout << "Saturday" << endl; 
	else if (n == 7) cout << "Sunday" << endl; 
	else cout << "No such day" << endl;
}
```
## Оператор выбора `switch`
Предыдущий пример написан с использованием 7 условных операторов, вложенных один в другой. Но его же можно выполнить одним оператором выбора `switch`.
```cpp
switch (выражение) {
case значение_1:
	код_1;
	break;
case значение_2:
	код_2;
	break;
case значение_n:
	код_n;
	break;
default:
	код;
}
```
Для примера со днями недели:
```cpp
switch(n) {
case 1: cout << "Monday"; break;
case 2: cout << "Tuesday"; break;
case 3: cout << "Wednesday"; break;
case 4: cout << "Thursday"; break;
case 5: cout << "Friday"; break;
case 6: cout << "Saturday"; break;
case 7: cout << "Sunday"; break;
default: cout << "No such day";
}
```
Каждая ветвь `case` обычно заканчивается оператором `break`, который прекращает работу внешнего оператора `switch`. Если в конце ветви `case` `break` не стоит, то будут выполняться следующие ветви, либо пока не встретится `break`, либо пока не закончится оператор `switch`. Если значение выражения после `switch` не найдено ни в одной ветви, по умолчанию выполняется ветвь `default`.
## Команды и операторы цикла
В языке C/C++ существуют 3 вида циклов:
- цикл с предусловием `while`
- цикл с постусловием `do while`
- цикл с параметром `for`
#### Оператор цикла `while`
```cpp
while (выражение) оператор;
```
Пример:
```cpp
int n = 10, f = 1, i = 1;
while (i <= n) {
	f = f * i;
	i++;
}
cout << "f = " << f << endl;
```
Оператор, называемый **телом цикла**, выполняется до тех пор, пока условие истинно. Если условие ложно изначально, тело цикла не выполнится ни разу. Если оно постоянно истинно, произойдет зацикливание.  
В примере цикл вычисляет факториал числа `n`:
```cpp
int n = 5, f = 1, i = 1;
while (i <= n) f *= i++;
cout << "f = " << f << endl;
```
#### Оператор цикла `do while`
```cpp
do оператор while (выражение);
```
Пример:
```cpp
int n = 10, f = 1, i = 1;
do {
	f = f * i;
	i++;
}
while (i <= n)
cout << "f = " << f << endl;
```
Выход из цикла производится также по ложности условия, но тело цикла будет выполнено всегда хотя бы 1 раз.
#### Оператор цикла `for`
```cpp
for (инициализация; выражение; модификация) оператор;
```
Пример:
```cpp
int n = 10; f = 1;
for (int i = 1; i <= n; i++) f *= i;
cout << "f = " << f << endl;
```
Обязательная часть цикла `for`, заключенная в круглые скобки, состоит из 3 разделов, отделенных точкой с запятой:
- 1 раздел - описание и инициализация локальных переменных цикла. Если переменных несколько - перечисляются через запятую
- 2 раздел - логическое выражение, по достижении ложности которого происходит выход из цикла
- 3 раздел - модификация значений некоторых переменных
  
Как правило, в разделе инициализации описывается параметр (счетчик) цикла, а в разделе модификации меняется его значение.  
## Примеры программ с циклами
#### Вычисление сумм и произведений
1. $\frac{1}{2}+\frac{3}{4}+\frac{5}{6}+...$ ($n$ слагаемых)
```cpp
int n = 5; double s = 0;
for (double i = 1; i <= n; i++) {
	s = s + (2 * i - 1) / (2 * i);
	cout << "s = " << s << endl;
}
```
2. $\frac{1}{1}-\frac{2}{1∗2}+\frac{3}{1∗2∗3}-\frac{4}{1∗2∗3∗4}+...$ ($n$ слагаемых)
```cpp
int = 2, znak = 1;
double s = 0, ch = 1, zn = 1;
for (double i = 1; i <= n; i++) {
	s += znak * ch / zn;
	ch += 2;
	zn *= (i + 1);
	znak = -znak;
}
```
3. $(1+\frac{1}{1})(2-\frac{2}{1∗2})(4+\frac{4}{1∗2∗3})(8-\frac{7}{1∗2∗3∗4})(16+\frac{11}{1∗2∗3∗4∗5})...$ ($n$ множителей)
```cpp
int n = 3, znak = 1;
double p = 1, sl = 1, ch = 1, zn = 1;
for (int i = 1; i <= n; i++) {
	p *= (sl + znak * ch / zn);
	sl *= 2;
	ch += i;
	zn *= (i + 1);
	znak = -znak;
}
```
#### Работа с цифрами числа
1. Дано натуральное число `n`. Найти количество, сумму и произведение его цифр.  
  
Последняя цифра числа в 10-чной системе счисления находится как остаток от деления на 10. Посчитаем ее, добавим сумму и произведение, после чего обрежем число на эту цифру делением на 10. Так до тех пор, пока число не обратится в 0.
```cpp
int n;
cout << "n = "; cin >> n;
int tmp = n, k = 0, s = 0, p = 1;
while (tmp > 0) {
	int digit = tmp % 10;
	k += 1;
	s += digit;
	p += digit;
	tmp /= 10;
}
cout << "k = " << k << endl;
cout << "s = " << s << endl;
cout << "p = " << p << endl;
```
2. Найти все числа от 1 до `n`, равные сумме факториалов своих цифр.
  
Например, $145=1!+4!+5!=1+24+120$
```cpp
for (int i = 1; i <= n; i++) {
	a = i;
	while (a > 0) {
		int digit = a % 10;
		int f = 1;
		for (int j = 2; j <= digit; j++) f *= j;
		s += f;
		a /= 10;
	}
	if (s == i) cout << i << " ";
}
```
3. **Игра "Быки и коровы"** - логическая игра, в которой один игрок загадывает число, а другой пытается угадать его за определённое количество ходов.
  
Например, загадано число 9037:
1) 0123: 2 - 0 (2 верно, 0 на своем месте)
2) 2468: 0 - 0 (0 верно, 0 на своем месте)
3) 9307: 4 - 2 (4 верно, 2 на своем месте)
4) 9037: 4 - 4 (4 верно, 4 на своем месте)
  
Компьютер должен загадать случайное 4-значное число, используя генератор псевдослучайных чисел и функцию `rand`, которая возвращает случайное число из отрезка `[0; 32767]` (32767 = $2^{15}-1$).
Реализация генератора псевдослучайных чисел:
```cpp
#include <time.h>

int main() {
	srand(time(0));
	cout << rand() % 10 << rand() % 10 << rand() % 10 << rand() % 10 << endl;
}
```
Реализация игры:
```cpp
#include <iostream>
#include <time.h>
using namespace std;

int main() {
	srand(time(0));
	int a, b, c, d, n, a1, b1, c1, d1, com bu, k = 0;
	do {
		a = rand() % 10;
		b = rand() % 10;
		c = rand() % 10;
		d = rand() % 10;
	} while (a == b || a == c || a == d || b == c || b == d || c == d);
	cout << a << b << c << d << endl;
	do {
		cout << "Enter your number: ";
		cin >> n;
		a1 = n / 1000;
		b1 = n / 100 % 10;
		c1 = n / 10 % 10;
		d1 = n % 10;
		co = 0;
		if (a == a1 || a == b1 || a == c1 || a == d1) co++;
		if (b == a1 || b == b1 || b == c1 || b == d1) co++;
		if (c == a1 || c == b1 || c == c1 || c == d1) co++;
		if (d == a1 || d == b1 || d == c1 || d == d1) co++;
		bu = 0;
		if (a == a1) bu++;
		if (b == b1) bu++;
		if (c == c1) bu++;
		if (d == d1) bu++;
		cout << co << " - " << bu << endl;
		k++;
	} while (bu != 4);
	cout << "Congratulations!!!" << endl;
	cout << "You won!!!" << endl;
	cout << "Number of steps: " << k << endl;
	cout << endl;
	system("pause");
	return 0;
}
```
#### Работа с делителями числа
1. Дано натуральное число `n`. Найти количество, сумму и произведение всех его делителей.  
  
Все возможные делители числа `n` принадлежат отрезку `[1; n]`. Будем пытаться делить число `n` на каждое натуральное из этого отрезка, и если остаток от деления равен 0 - это делитель и его надо посчитать.
```cpp
int n;
cout << "n = "; cin >> n;
int k = 0, s = 0, p = 1;
for (int del = 2; del <= sqrt(i); del++)
	if (n % del == 0) {
		k += 1;
		s += del;
		p *= del;
	}
```
2. Вывести таблицу простых чисел от 2 до `n`.
  
Будем перебирать все натуральные числа на отрезке `[2; n]` и считать у каждого из них количество делителей. Если оно равно 2 - число простое, его надо вывести.
```cpp
int n;
cout << "n = "; cin >> n;
for (int i = 2; i = 2; i <= n; i++) {
	int k = 0;
	for (int del = 1; del <= i; del++)
		if (i % del == 0) k++;
	if (k == 2) cout << i << " ";
}
```
