**Массив** - это структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов.  
![Массивы](../Pictures/02_01.%20Массивы.png)  
![Массивы](../Pictures/02_02.%20Двумерный%20массив.png)  
![Хранение изображения с помощью массива](../Pictures/02_03.%20Хранение%20изображения%20с%20помощью%20массива.png)  
**NumPy** (Numerical Python - "числовой Python") - мультимодульный пакет, представляющий собой библиотеку типов и функций для работы с массивами.
```python
import numpy as np
```
## Создание массивов с NumPy
```python
arr = np.array([1, 4, 2, 5, 3]) # Создание массива с помощью списка чисел

array([1, 4, 2, 5, 3])
```
  
```python
np.array(['a', 'b', 'c'])

array(['a', 'b', 'c'], dtype = '<U1')
```
  
```python
np.array([3.14, 4, 2, 3]) # Если типы элементов не совпадают, NumPy попытается выполнить повышающее приведение типов

array([3.14, 4. , 2. , 3. ])
```
  
```python
np.array([3.14, 4, 2, 3], dtype = int)

array([3, 4, 2, 3])
```
  
```python
# Создаем массив целых чисел длины 10, заполненный нулями
np.zeros(10, dtype = int)

array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```
  
```python
# Создаем массив размером 3 x 5 значений с плавающей точкой, заполненный единицами
np.ones((3, 5), dtype = float)

array([[1., 1., 1., 1., 1.], 
	[1., 1., 1., 1., 1.], 
	[1., 1., 1., 1., 1.]])
```
  
```python
# Создаем массив размером 3 x 5, заполненный значением 3.14
np.full((3, 5), 3.14)

array([[3.14, 3.14, 3.14, 3.14, 3.14], 
	[3.14, 3.14, 3.14, 3.14, 3.14], 
	[3.14, 3.14, 3.14, 3.14, 3.14]])
```
  
```python
# Создаем массив, заполненный линейной последовательностью, начинающейся с 0 и заканчивающейся 20, с шагом 2 (аналогично встроенной функции range())
np.arange(0, 20, 2)

array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18])
```
  
```python
# Создаем массив из пяти значений, равномерно располагающихся между 0 и 1
np.linspace(0, 1, 5)

array([0. , 0.25, 0.5 , 0.75, 1. ])
```
  
```python
# Создаем массив размером 3 x 3 равномерно распределенных случайных значения от 0 до 1
np.random.random((3, 3))

array([[0.20726223, 0.2238221 , 0.56085716], 
	[0.10008193, 0.19832616, 0.69210559], 
	[0.2844972 , 0.77425735, 0.29902387]])
```
  
```python
# Создаем массив размером 3 x 3 случайных целых числа в промежутке [0, 10)
np.random.randint(0, 10, (3, 3))

array([[2, 8, 3], 
	[8, 9, 4], 
	[6, 0, 1]])
```
## Атрибуты массивов библиотеки NumPy
```python
np.random.seed(0) # начальное значение для целей воспроизводимости
x1 = np.random.randint(10, size=6) # одномерный массив
x2 = np.random.randint(10, size=(3, 4)) # двумерный массив
x3 = np.random.randint(10, size=(3, 4, 5)) # трехмерный массив

x1 = array([5, 0, 3, 3, 7, 9])
x2 = array([[3, 5, 2, 4], 
	[7, 6, 8, 8], 
	[1, 6, 7, 7]])
x3 = array([[[8, 1, 5, 9, 8], 
	[9, 4, 3, 0, 3], 
	[5, 0, 2, 3, 8], 
	[1, 3, 3, 3, 7]], 
	
	[[0, 1, 9, 9, 0], 
	[4, 7, 3, 2, 7], 
	[2, 0, 0, 4, 5], 
	[5, 6, 8, 4, 1]], 
	
	[[4, 9, 8, 1, 1], 
	[7, 9, 9, 3, 6], 
	[7, 2, 0, 3, 5], 
	[9, 4, 4, 6, 4]]])
```
**Массивы** - это объекты класса `ndarray` со своими атрибутами и методами.  
```python
print(type(x1), type(x2), type(x3))

<class 'numpy.ndarray'> <class 'numpy.ndarray'> <class 'numpy.ndarray'>
```
Рассмотрим некоторые атрибуты объектов `ndarray`:  
- `ndarray.ndim` - размерность массива
- `ndarray.shape` - размер каждого измерения  
- `ndarray.size` - количество элементов массива  
- `ndarray.dtype` - тип элементов массива (можно определить `dtype`, используя стандартные типы данных Python)
  
**Размерность массива** - это количество индексов, необходимое для однозначной адресации элемента в рамках массива. По количеству используемых индексов массивы делятся на одномерные, двумерные, трехмерные и т. д.  
```python
print(x1)
print("x1 ndim: ", x1.ndim)
print("x1 shape:", x1.shape)
print("x1 size: ", x1.size)
print("x1 dtype: ", x1.dtype) # int 32 - целое число от –2 147 483 648 до 2 147 483 647

[5 0 3 3 7 9] 
x1 ndim: 1 
x1 shape: (6,) 
x1 size: 6 
x1 dtype: int32
```
  
```python
print(x2)
print("x2 ndim: ", x2.ndim)
print("x2 shape:", x2.shape)
print("x2 size: ", x2.size)
print("x1 dtype: ", x2.dtype)

[[3 5 2 4] 
[7 6 8 8] 
[1 6 7 7]] 
x2 ndim: 2 
x2 shape: (3, 4) 
x2 size: 12 
x1 dtype: int32
```
  
```python
print(x3)
print("x3 ndim: ", x3.ndim)
print("x3 shape:", x3.shape)
print("x3 size: ", x3.size)
print("x1 dtype: ", x3.dtype)

[[[8 1 5 9 8] 
[9 4 3 0 3] 
[5 0 2 3 8] 
[1 3 3 3 7]] 

[[0 1 9 9 0] 
[4 7 3 2 7] 
[2 0 0 4 5] 
[5 6 8 4 1]] 

[[4 9 8 1 1] 
[7 9 9 3 6] 
[7 2 0 3 5] 
[9 4 4 6 4]]] 
x3 ndim: 3 
x3 shape: (3, 4, 5) 
x3 size: 60 
x1 dtype: int32
```
## Индексация массивов
```python
np.random.seed(0)
x1 = np.random.randint(10, size=6) # одномерный массив
x2 = np.random.randint(10, size=(3, 4)) # двумерный массив
x3 = np.random.randint(10, size=(3, 4, 5)) # трехмерный массив

x1 = array([5, 0, 3, 3, 7, 9])
x1[0] = 5
x1[2] = 3
x1[-1] = 9
x2 = array([[3, 5, 2, 4], 
	[7, 6, 8, 8], 
	[1, 6, 7, 7]])
x2[0][0] = 3
```
Обращаться к элементам в многомерном массиве можно с помощью разделенных запятыми кортежей индексов:
```python
x2[0, -1] = 4
x3 = array([[[8, 1, 5, 9, 8], 
	[9, 4, 3, 0, 3], 
	[5, 0, 2, 3, 8], 
	[1, 3, 3, 3, 7]], 
	
	[[0, 1, 9, 9, 0], 
	[4, 7, 3, 2, 7], 
	[2, 0, 0, 4, 5], 
	[5, 6, 8, 4, 1]], 
	
	[[4, 9, 8, 1, 1], 
	[7, 9, 9, 3, 6], 
	[7, 2, 0, 3, 5], 
	[9, 4, 4, 6, 4]]])
x3[0, 2, 4] = 8
```
Также можно изменить значения, используя любую из перечисленных выше индексных нотаций:
```python
x2 = array([[3, 5, 2, 4], 
	[7, 6, 8, 8], 
	[1, 6, 7, 7]])

x2[0, 0] = 10

x2 = array([[10, 5, 2, 4], 
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 7]])

x2[-1][-1] = 6.91

x2 = array([[10, 5, 2, 4], # Числа после точки были отброшены!
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 6]])
```
#### "Прихотливая" индексация
Суть **«прихотливой» индексации** проста: она заключается в передаче массива индексов с целью одновременного доступа к нескольким элементам массива.
```python
x = np.random.randint(100, size=10)
print(x)

[47 3 76 52 78 15 20 99 58 23]
```
  
```python
[x[3], x[7], x[2]]

[52, 99, 76]
```
  
```python
ind = [3, 7, 4]
x[ind]

array([52, 99, 78])
```
В случае «прихотливой» индексации форма результата отражает форму массивов индексов, а не форму индексируемого массива.
```python
ind = np.array([[3, 7],[4, 5]])
x[ind]

array([[52, 99], 
	[78, 15]])
```
Аналогично тому, как «прихотливую» индексацию можно использовать для доступа к частям массива, ее можно применять и для модификации частей массива.
```python
x = np.arange(10)
i = np.array([2, 1, 8, 4])
x[i] = 99
print(x)

[ 0 99 99 3 99 5 6 7 99 9]
```
## Срезы массивов
Для доступа к срезу массива `x` используется синтаксис: `x[начало:конец:шаг]`. Если какие-либо из этих значений не указаны, значения применяются по умолчанию: начало = 0, конец = размер соответствующего измерения, шаг = 1.
```python
x1 = array([5, 0, 3, 3, 7, 9])
```
  
```python
x1[:4] = array([5, 0, 3, 3])
```
  
```python
x1[4:] = array([7, 9])
```
  
```python
x1[-3:-1] = array([3, 7])
```
  
```python
x1[::2] = array([5, 3, 7])
```
  
```python
x2 = array([[10, 5, 2, 4], 
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 6]])
```
  
```python
x2[:2] = array([[10, 5, 2, 4], 
	[ 7, 6, 8, 8]])
```
Многомерные срезы задаются схожим образом, с разделением срезов запятыми.
```python
x2[:2, :3] # две строки, три столбца
array([[10, 5, 2], 
	[ 7, 6, 8]])
```
  
```python
x2[:, 1:] # Все строки и три последних столбца

array([[5, 2, 4], 
	[6, 8, 8], 
	[6, 7, 6]])
```
  
```python
# Измерения подмассивов также можно «переворачивать»:
x2[::-1, ::-1]

array([[ 6, 7, 6, 1], 
	[ 8, 8, 6, 7], 
	[ 4, 2, 5, 10]])
```
  
```python
x3 = array([[[8, 1, 5, 9, 8], 
	[9, 4, 3, 0, 3], 
	[5, 0, 2, 3, 8], 
	[1, 3, 3, 3, 7]], 
	
	[[0, 1, 9, 9, 0], 
	[4, 7, 3, 2, 7], 
	[2, 0, 0, 4, 5], 
	[5, 6, 8, 4, 1]], 
	
	[[4, 9, 8, 1, 1], 
	[7, 9, 9, 3, 6], 
	[7, 2, 0, 3, 5], 
	[9, 4, 4, 6, 4]]])
```
  
```python
x3[:2, :1] = array([[[8, 1, 5, 9, 8]], 
	[[0, 1, 9, 9, 0]]])
```
  
```python
x3[:2, :1, 1:] = array([[[1, 5, 9, 8]], 
	[[1, 9, 9, 0]]])
```
В списках срезы являются копиями, в массивах NumPy - представлениями
```python
x2 = array([[10, 5, 2, 4], 
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 6]])
```
  
```python
# Извлечем из него двумерный подмассив 2 × 2:
x2_sub = x2[:2, :2]
print(x2_sub)

[[10 5] 
[ 7 6]]
```
  
```python
# Теперь, если мы изменим этот подмассив, то увидим, что исходный массив также поменялся!
x2_sub[0, 0] = 99
x2_sub

array([[99, 5], 
	[ 7, 6]])
```
  
```python
x2 = array([[99, 5, 2, 4], 
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 6]])
```
  
```python
# Создание копий
x2 = array([[99, 5, 2, 4], 
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 6]])
```
  
```python
x2_sub_copy = x2[:2, :2].copy()
x2_sub_copy[0,0] = 55
```
  
```python
x2_sub_copy = array([[55, 5], 
	[ 7, 6]])
```
  
```python
x2 = array([[99, 5, 2, 4], 
	[ 7, 6, 8, 8], 
	[ 1, 6, 7, 6]])
```
## Изменение формы массива
```python
grid = np.arange(1, 10)
grid

array([1, 2, 3, 4, 5, 6, 7, 8, 9])
```
  
```python
grid.reshape((3, 3))

array([[1, 2, 3], 
	[4, 5, 6], 
	[7, 8, 9]])
```
## Слияние и разбиение массивов
Слияние, или объединение, двух массивов в библиотеке NumPy выполняется в основном с помощью `np.concatenate`, `np.vstack` и `np.hstack`.
```python
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
np.concatenate([x, y]) # Слияние двух массивов

array([1, 2, 3, 3, 2, 1])
```
  
```python
z = [99, 99, 99]
print(np.concatenate([x, y, z])) # Слияние трех массивов

[ 1 2 3 3 2 1 99 99 99]
```
  
```python
grid = np.array([[1, 2, 3], [4, 5, 6]])
```
Для объединения двумерных массивов можно также использовать `np.concatenate`:
```python
# Слияние по нулевой оси координат
np.concatenate([grid, grid])

array([[1, 2, 3], 
	[4, 5, 6], 
	[1, 2, 3], 
	[4, 5, 6]])
```
  
```python
# Слияние по первой оси координат
np.concatenate([grid, grid], axis=1)

array([[1, 2, 3, 1, 2, 3], 
	[4, 5, 6, 4, 5, 6]])
```
Для работы с массивами с различающимися измерениями удобнее и понятнее использовать функции `np.vstack` (вертикальное объединение) и `np.hstack` (горизонтальное объединение):
```python
x = np.array([1, 2, 3])
grid = np.array([[9, 8, 7], [6, 5, 4]])

# Объединяет массивы по вертикали
np.vstack([x, grid])

array([[1, 2, 3], 
	[9, 8, 7], 
	[6, 5, 4]])
```
  
```python
y = np.array([[99],[99]])

# Объединяет массивы по горизонтали
np.hstack([grid, y])

array([[ 9, 8, 7, 99],
	[ 6, 5, 4, 99]])
```
Противоположностью слияния является разбиение, выполняемое с помощью функций `np.split`, `np.hsplit` и `np.vsplit`.
```python
x = [1, 2, 3, 99, 99, 3, 2, 1]
x1, x2, x3 = np.split(x, [3, 5])
print(x1, x2, x3)

[1 2 3] [99 99] [3 2 1]
```

```python
grid = np.arange(16).reshape((4, 4))
grid

array([[ 0, 1, 2, 3], 
	[ 4, 5, 6, 7], 
	[ 8, 9, 10, 11], 
	[12, 13, 14, 15]])
```
  
```python
upper, lower = np.vsplit(grid, [2]) # Второй массив начнется со строки, имеющей индекс 2 в исходном массиве
print(upper)
print(lower)

[[0 1 2 3] 
[4 5 6 7]] 
[[ 8 9 10 11] 
[12 13 14 15]]
```
  
```python
left, right = np.hsplit(grid, [2])
print(left)
print(right)

[[ 0 1] 
[ 4 5] 
[ 8 9] 
[12 13]] 

[[ 2 3] 
[ 6 7] 
[10 11] 
[14 15]]
```
## Выполнение вычислений над массивами библиотеки NumPy
Выполнение вычислений над массивами библиотеки NumPy может быть очень быстрым и очень медленным. Реализация языка Python по умолчанию выполняет некоторые операции очень медленно. Частично это происходит из-за динамической, интерпретируемой природы языка.  
Компилируемый язык программирования - язык программирования, исходный код которого преобразуется компилятором в машинный код и записывается в файл. В отличие от компилируемых языков, интерпретируемым для исполнения программы не нужен машинный код, вместо этого программу построчно исполнят интерпретаторы.  
Ключ к ускорению - использование векторизованных операций, обычно реализуемых посредством универсальных функций языка Python.
#### Арифметические функции
| Оператор | Эквивалентная универсальная функция | Описание                                                     |
| -------- | ----------------------------------- | ------------------------------------------------------------ |
| `+`      | `np.add`                            | Сложение (например, `1+1=2`)                                 |
| `-`      | `np.substract`                      | Вычитание (например, `3-2=1`)                                |
| `-`      | `np.negative`                       | Унарная операция изменения знака (например, `-2`)            |
| `*`      | `np.multiply`                       | Умножение (например, `2*3=6`)                                |
| `/`      | `np.divide`                         | Деление (например, `3/2=1.5`)                                |
| `//`     | `np.floor_divide`                   | Деление с округлением в меньшую сторону (например, `3//2=1`) |
| `**`     | `np.power`                          | Возведение в степень (например, `2**3=8`)                    |
| `%`      | `np.mod`                            | Модуль/остаток (например, `9 \% 4=1`)                        |
  
```python
x = np.arange(4)
print("x =", x)
print("x + 5 =", x + 5)
print("x - 5 =", x - 5)
print("x * 2 =", x * 2)
print("x / 2 =", x / 2)
print("x // 2 =", x // 2) # деление с округлением в меньшую сторону

x = [0 1 2 3] 
x + 5 = [5 6 7 8] 
x - 5 = [-5 -4 -3 -2] 
x * 2 = [0 2 4 6] 
x / 2 = [0. 0.5 1. 1.5] 
x // 2 = [0 0 1 1]
```
  
```python
print("-x = ", -x) # унарная универсальная функция для операции изменения знака
print("x ** 2 = ", x ** 2)
print("x % 2 = ", x % 2)

-x = [ 0 -1 -2 -3] 
x ** 2 = [0 1 4 9] 
x % 2 = [0 1 0 1]
```
  
```python
-(0.5*x + 1) ** 2

array([-1. , -2.25, -4. , -6.25])
```
  
```python
np.add(x, 2) # функция эквивалентная оператору +

array([2, 3, 4, 5])
```
  
```python
x2 = np.arange(4,8)

x2 = array([4, 5, 6, 7])
```
  
```python
x + x2 = array([ 4, 6, 8, 10])
```
  
```python
x * x2 = array([ 0, 5, 12, 21])
```
  
```python
x = np.array([-2, -1, 0, 1, 2])
abs(x) # встроенная функция для вычисления абсолютного значения

array([2, 1, 0, 1, 2])
```
  
```python
np.abs(x) # функция для вычисления абсолютного значения из numpy

array([2, 1, 0, 1, 2])
```
#### Транслирование
Транслирование представляет собой набор правил по применению бинарных универсальных функций (сложение, вычитание, умножение и т. д.) к массивам различного размера.
```python
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])

a + b = array([5, 6, 7])
```
Транслирование в библиотеке NumPy следует строгому набору правил, определяющему взаимодействие двух массивов.  
- Правило 1: если размерность двух массивов отличается, форма массива с меньшей размерностью дополняется  с ведущей (левой) стороны.  
- Правило 2: если форма двух массивов не совпадает в каком-то измерении, массив с формой, равной 1 в данном измерении, растягивается вплоть до соответствия форме другого массива.  
- Правило 3: если в каком-либо измерении размеры массивов различаются и ни один не равен 1, генерируется ошибка.
  
```python
M = np.ones((2, 3))
a = np.arange(3)
```
  
```python
print(M)
print(a)

[[1. 1. 1.] 
[1. 1. 1.]] 
[0 1 2]
```
  
```python
print(M.shape)
print(a.shape)

(2, 3) 
(3,)
```
  
```python
M + a = array([[1., 2., 3.], 
[1., 2., 3.]])
```
  
```python
M = np.ones((3, 2))
a = np.arange(3)
```
  
```python
M = array([[1., 1.], 
	[1., 1.], 
	[1., 1.]])
```
  
```python
a = array([0, 1, 2])
```
  
```python
print(M.shape)
print(a.shape)

(3, 2) 
(3,)
```
  
```python
M + a = (3,2) (3,)
```
#### Некоторые полезные возможности универсальных функций
```python
# Указание массива для вывода результата
x = np.arange(5)
y = np.empty(5)
np.multiply(x, 10, out=y)
print(y)

[ 0. 10. 20. 30. 40.]
```
  
```python
# Вызов метода reduce для универсальной функции add возвращает сумму всех элементов массива
x = np.arange(1, 6)
np.add.reduce(x)

15
```
  
```python
# Вызов метода reduce для универсальной функции multiply возвращает произведение всех элементов массива:
np.multiply.reduce(x)

120
```
  
```python
np.multiply.accumulate(x) # Промежуточные результаты вычислений

array([ 1, 2, 6, 24, 120], dtype = int32)
```
#### Агрегирование
| Имя функции     | NaN-безопасная версия | Описание                                              |
| --------------- | --------------------- | ----------------------------------------------------- |
| `np.sum`        | `np.nansum`           | Вычисляет сумму элементов                             |
| `np.prod`       | `np.nanprod`          | Вычисляет произведение элементов                      |
| `np.mean`       | `np.nanmean`          | Вычисляет среднее значение элементов                  |
| `np.std`        | `np.nanstd`           | Вычисляет стандартное отклонение                      |
| `np.var`        | `np.nanvar`           | Вычисляет дисперсию                                   |
| `np.min`        | `np.nanmin`           | Вычисляет минимальное значение                        |
| `mp.max`        | `np.nanmax`           | Вычисляет максимальное значение                       |
| `np.argmin`     | `np.nanargmin`        | Возвращает индекс минимального значения               |
| `np.argmax`     | `np.nanargmax`        | Возвращает индекс максимального значения              |
| `np.median`     | `np.nanmedian`        | Вычисляет медиану элементов                           |
| `np.percentile` | `np.nanpercentile`    | Вычисляет квантили элементов                          |
| `np.any`        | `N/A`                 | Проверяет, существуют ли элементы со значением `true` |
| `np.all`        | `N/A`                 | Проверяет, все ли элементы имеют значение `true`      |
```python
big_array = np.random.rand(1000000)
```
  
```python
np.sum(big_array)

500208.7551046332
```
  
```python
np.mean(big_array)

0.5002087551046333
```
  
```python
big_array.max()

0.9999994392723005
```
  
```python
arr = np.array([1, 2, np.nan, 1])
```
  
```python
np.nanmean(arr)

1.3333333333333333
```
  
```python
M = np.random.random((3, 4))
print(M)

[[6.04713761e-01 4.39058151e-01 7.35259829e-01 3.70323200e-01] 
[5.73616027e-01 7.84029145e-01 7.50099011e-04 5.08583464e-01] 
[4.44828020e-01 2.17253314e-02 4.65670506e-01 9.04110146e-01]]
```
  
```python
M.sum(axis = 0) # Сумма по столбцам

array([1.62315781, 1.24481263, 1.20168043, 1.78301681])
```
  
```python
M.sum(axis = 1) # Сумма по строкам

array([2.14935494, 1.86697873, 1.836334 ])
```
  
```python
M.sum()

5.852667678824248
```
#### Сравнение
| Оператор | Эквивалентная универсальная функция |
| -------- | ----------------------------------- |
| ==       | `np.equal`                          |
| !=       | `np.not_equal`                      |
| <        | `np.less`                           |
| <=       | `np.less_equal`                     |
| >        | `np.greater`                        |
| >=       | `np.greater_equal`                  |
  
```python
x = np.array([1, 2, 3, 4, 5])
```
  
```python
x < 3

array([ True, True, False, False, False])
```
  
```python
x = np.random.randint(10, size = (3, 4))

x = array([[7, 3, 9, 7], 
	[6, 9, 6, 7], 
	[3, 5, 4, 6]])
```
  
```python
x < 6 = array([[False, True, False, False], 
	[False, False, False, False], 
	[ True, True, True, False]])
```
Для подсчета количества элементов `True` в булевом массиве удобно использовать функцию `np.count_nonzero`:
```python
np.count_nonzero(x < 6)

4
```
  
```python
# Сколько значений меньше 6 содержится в каждой строке?
np.sum(x < 6, axis = 1)

array([1, 0, 3])
```
Если вам необходимо быстро проверить, существует ли хоть одно истинное значение, или все ли значения истинны, можно воспользоваться функциями `np.any()` и `np.all()`:
```python
# Имеются ли в массиве какие-либо значения, превышающие 8?
np.any(x > 8)

True
```
  
```python
# Все ли значения в каждой строке меньше 8?
np.all(x < 8, axis = 1)

array([False, False, True])
```
Чтобы выбрать нужные значения из массива, достаточно просто проиндексировать исходный массив x по этому булеву массиву. Такое действие носит название операции наложения маски или **маскирования**:
```python
x = array([[7, 3, 9, 7], 
	[6, 9, 6, 7], 
	[3, 5, 4, 6]])
```
  
```python
x < 5 = array([[False, True, False, False], 
	[False, False, False, False], 
	[ True, False, True, False]])
```
  
```python
x[x < 5] # наложение маски

array([3, 3, 4])
```
  
```python
# При создании булева выражения с заданным массивом следует использовать операторы & и |, а не операции and или or:
x = np.arange(10)
x[(x > 4) & (x < 8)]

array([5, 6, 7])
```
## Структурированные массивы
```python
name = ['Alice', 'Bob', 'Cathy', 'Doug']
age = [25, 45, 37, 19]
weight = [55.0, 85.5, 68.0, 61.5]
```
  
```python
# Используем для структурированного массива составной тип данных
data = np.zeros(4, dtype = {'names':('name', 'age', 'weight'),'formats':('U10', 'i4', 'f8')})
# ([('name', 'U10'), ('age', 'i8'), ('weight', 'f4')]
print(data)
print(data.dtype)

[('', 0, 0.) ('', 0, 0.) ('', 0, 0.) ('', 0, 0.)] 
[('name', '<U10'), ('age', '<i4'), ('weight', '<f8')]
```
  
```python
data['name'] = name
data['age'] = age
data['weight'] = weight
print(data)

[('Alice', 25, 55. ) ('Bob', 45, 85.5) ('Cathy', 37, 68. ) ('Doug', 19, 61.5)]
```
  
```python
# Извлечь возраст
data['age']

array([25, 45, 37, 19])
```
  
```python
# Извлечь первую строку данных
data[0]

('Alice', 25, 55.)
```
  
```python
# Извлечь имя из последней строки
data[-1]['name']

'Doug'
```
  
```python
# Извлечь имена людей с возрастом менее 30
data[data['age'] < 30]['name']

array(['Alice', 'Doug'], dtype = '<U10')
```
## Массивы записей
```python
data_rec = data.view(np.recarray) # view - создает новый вид массива с такими же данными
data_rec

rec.array([('Alice', 25, 55. ), ('Bob', 45, 85.5), ('Cathy', 37, 68. ), ('Doug', 19, 61.5)], 
	dtype = [('name', '<U10'), ('age', '<i4'), ('weight', '<f8')])
```
  
```python
data_rec.age

array([25, 45, 37, 19])
```