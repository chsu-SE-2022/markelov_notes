<html>
<head>
   <title>Запросы с использованием единственной таблицы</title>

</head>
<body background="fon.jpg">
<div align="center"><b><font>Глава 2. Запросы с использованием единственной таблицы</font></b></div><font size = "-1">
<div align="center"><b><font>2.1. О предложении SELECT</font></b></div><font size = "-1">


<p align=justify>Все запросы на получение практически любого количества данных из одной или нескольких таблиц выполняются с помощью единственного предложения SELECT. В общем случае результатом реализации предложения SELECT является другая таблица (см. примеры п.<a href=1-3.htm>1.3</a>). К этой новой (рабочей) таблице может быть снова применена операция SELECT и т.д., т.е. такие операции могут быть вложены друг в друга. Представляет исторический интерес тот факт, что именно возможность включения одного предложения SELECT внутрь другого послужила мотивировкой использования прилагательного "структуризированный" в названии языка SQL.			</P>
<p align=justify>Предложение SELECT может использоваться как:</P>
<UL>
<LI> самостоятельная команда на получение и вывод строк таблицы, сформированной из столбцов и строк одной или нескольких таблиц (представлений);
<LI>	элемент WHERE- или HAVING-условия (сокращенный вариант предложения, называемый "вложенный запрос");
<LI>	фраза выбора в командах CREAT VIEW, DECLARE CURSOR или INSERT;
<LI>	средство присвоения глобальным переменным значений из строк сформированной таблицы (INTO-фраза).
</UL>
<p align=justify>В данной и следующей главах будут рассмотрены только две первые функции предложения SELECT, а здесь – его синтаксис, ограниченный конструкциями, используемыми при реализации этих функций. Здесь (так же как и в других главах книги) в синтаксических конструкциях используются следующие обозначения:</P>
<UL>
<li> звездочка (*) для обозначения "все" - употребляется в обычном для программирования смысле, т.е. "все случаи, удовлетворяющие определению";
<li> квадратные скобки ([]) – означают, что конструкции, заключенные в эти скобки, являются необязательными (т.е. могут быть опущены);
<li> фигурные скобки ({}) – означают, что конструкции, заключенные в эти скобки, должны рассматриваться как целые синтаксические единицы, т.е. они позволяют уточнить порядок разбора синтаксических конструкций, заменяя обычные скобки, используемые в синтаксисе SQL;
<li> многоточие (...) – указывает на то, что непосредственно предшествующая ему синтаксическая единица факультативно может повторяться один или более раз;
<li> прямая черта (|) – означает наличие выбора из двух или более возможностей. Например обозначение ASC|DESC указывает, можно выбрать один из терминов ASC или DESC; когда же один из элементов выбора заключен в квадратные скобки, то это означает, что он выбирается по умолчанию (так, [ASC]|DESC означает, что отсутствие всей этой конструкции будет восприниматься как выбор ASC);
<li> точка с запятой (;) – завершающий элемент предложений SQL;
<li> запятая (,) – используется для разделения элементов списков;
<li> пробелы ( ) – могут вводиться для повышения наглядности между любыми синтаксическими конструкциями предложений SQL;
<li> прописные жирные латинские буквы и символы – используются для написания конструкций языка SQL и должны (если это специально не оговорено) записываться в точности так, как показано;
<li> строчные буквы – используются для написания конструкций, которые должны заменяться конкретными значениями, выбранными пользователем, причем для определенности отдельные слова этих конструкций связываются между собой символом подчеркивания (_);
<li> термины таблица, столбец, ... – заменяют (с целью сокращения текста синтаксических конструкций) термины имя_таблицы, имя_столбца, ..., соответственно;
<li> термин таблица – используется для обобщения таких видов таблиц, как базовая_таблица, представление или псевдоним; здесь псевдоним служит для временного (на момент выполнения запроса) переименования и (или) создания рабочей копии базовой_таблицы (представления).
</UL>

<p align=justify>Предложение SELECT (выбрать) имеет следующий формат:</P>
<pre>
подзапрос [UNION [ALL] подзапрос] ...
[ORDER BY	{[таблица.]столбец | номер_элемента_SELECT}
                               [[ASC] | DESC]
[,{[таблица.]столбец | номер_элемента_SELECT}
                         [[ASC] | DESC]] ...;
</pre>
<p align=justify>и позволяет объединить (UNION) а затем упорядочить (ORDER BY) результаты выбора данных, полученных с помощью нескольких "подзапросов". При этом упорядочение можно производить в порядке возрастания - ASC (ASCending) или убывания DESC (DESCending), а по умолчанию принимается ASC.</P>
<p align=justify>В этом предложении подзапрос позволяет указать условия для выбора нужных данных и (если требуется) их обработки</P>

<DL>
<DT>	SELECT<DD>	(выбрать) данные из указанных столбцов и (если необходимо) выполнить перед выводом их преобразование в соответствии с указанными выражениями и (или) функциями
<DT>	FROM<DD>	(из) перечисленных таблиц, в которых расположены эти столбцы
<DT>	WHERE<DD>	(где) строки из указанных таблиц должны удовлетворять указанному перечню условий отбора строк
<DT>	GROUP BY<DD>	(группируя по) указанному перечню столбцов с тем, чтобы получить для каждой группы единственное агрегированное значение, используя во фразе SELECT SQL-функции SUM (сумма), COUNT (количество), MIN (минимальное значение), MAX (максимальное значение) или AVG (среднее значение)
<DT>	HAVING<DD>	(имея) в результате лишь те группы, которые удовлетворяют указанному перечню условий отбора групп</DL>


<P>и имеет формат</P>
<PRE>
SELECT	[[ALL] | DISTINCT]{ * | элемент_SELECT 
                  [,элемент_SELECT] ...}
FROM		{базовая_таблица | представление} [псевдоним]
[,{базовая_таблица | представление} [псевдоним]] ...
[WHERE		фраза]
[GROUP BY фраза [HAVING фраза]];</PRE>

<p align=justify>Элемент_SELECT - это одна из следующих конструкций:</P>
<PRE>
[таблица.]* | значение | SQL_функция |
               системная_переменная
</PRE>

<P>где значение – это:</P>

<PRE>
[таблица.]столбец | (выражение) | константа |
                       переменная</PRE>

<P>Синтаксис выражений имеет вид</P>

<PRE>
( {[ [+] | - ] {значение | функция_СУБД}
             [ + | - | * | ** ]}... )</PRE>

<P>а синтаксис SQL_функций – одна из следующих конструкций:</P>

<PRE>
{SUM|AVG|MIN|MAX|COUNT} 
           ( [[ALL]|DISTINCT][таблица.]столбец )

{SUM|AVG|MIN|MAX|COUNT} ( [ALL] выражение )

COUNT(*)</PRE>

<P>Фраза WHERE включает набор условий для отбора строк:</P>

<PRE>
WHERE [NOT] WHERE_условие 
           [[AND|OR][NOT] WHERE_условие]... </PRE>

<P>где WHERE_условие – одна из следующих конструкций:</P>

<PRE>
значение { = | <> | < | <= | > | >= } 
                     { значение | ( подзапрос ) }

значение_1 [NOT] BETWEEN значение_2 AND значение_3

значение [NOT] IN { ( константа [,константа]... ) 
                                 | ( подзапрос ) }

значение IS [NOT] NULL

[таблица.]столбец [NOT] LIKE 'строка_символов' 
                             [ESCAPE 'символ']

EXISTS ( подзапрос )
</PRE>
<p align=justify>Кроме традиционных операторов сравнения (= | &lt;> | &lt; | &lt;= | > | >=) в WHERE фразе используются условия BETWEEN (между), LIKE (похоже на), IN (принадлежит), IS NULL (не определено) и EXISTS (существует), которые могут предваряться оператором NOT (не). Критерий отбора строк формируется из одного или нескольких условий, соединенных логическими операторами:</P>

<DL>
<DT>AND	<DD>-	когда должны удовлетворяться оба разделяемых с помощью AND условия;
<DT>OR	<DD>-	когда должно удовлетворяться одно из разделяемых с помощью OR условий;
<DT>AND NOT	<DD>-	когда должно удовлетворяться первое условие и не должно второе;
<DT>OR NOT	<DD>-	когда или должно удовлетворяться первое условие или не должно удовлетворяться второе,</DL>

<p align=justify>причем существует приоритет AND над OR (сначала выполняются все операции AND и только после этого операции OR). Для получения желаемого результата WHERE условия должны быть введены в правильном порядке, который можно организовать введением скобок.</P>
<p align=justify>При обработке условия числа сравниваются алгебраически - отрицательные числа считаются меньшими, чем положительные, независимо от их абсолютной величины. Строки символов сравниваются в соответствии с их представлением в коде, используемом в конкретной СУБД, например, в коде ASCII. Если сравниваются две строки символов, имеющих разные длины, более короткая строка дополняется справа пробелами для того, чтобы они имели одинаковую длину перед осуществлением сравнения.</P>
<p align=justify>Наконец, синтаксис фразы GROUP BY имеет вид</P>
<PRE>
GROUP BY [таблица.]столбец [,[таблица.]столбец] ... 
                                 [HAVING фраза]
</PRE>

<p align=justify>GROUP BY инициирует перекомпоновку формируемой таблицы по группам, каждая из которых имеет одинаковое значение в столб-цах, включенных в перечень GROUP BY. Далее к этим группам применяются агрегирующие функции, указанные во фразе SELECT, что приводит к замене всех значений группы на единственное значение (сумма, количество и т.п.).</P>
<p align=justify>С помощью фразы HAVING (синтаксис которой почти не отличается от синтаксиса фразы WHERE)</P>
<PRE>
HAVING [NOT] HAVING_условие 
            [[AND|OR][NOT] HAVING_условие]... 
</PRE>

<p align=justify>можно исключить из результата группы, не удовлетворяющие заданным условиям:</P>
	
<PRE>
значение { = | &lt;> | &lt; | &lt;= | > | >= } { значение 
| ( подзапрос ) | SQL_функция }

{значение_1 | SQL_функция_1} [NOT] BETWEEN
	{значение_2 | SQL_функция_2} AND {значение_3 
	                    | SQL_функция_3}

{значение | SQL_функция} [NOT] IN
 { ( константа [,константа]... ) | ( подзапрос ) }

{значение | SQL_функция} IS [NOT] NULL

[таблица.]столбец [NOT] LIKE 'строка_символов' 
         [ESCAPE 'символ']

EXISTS ( подзапрос )
</PRE>

<p align="center">
<a href="1-3.htm">1.3</a> | <a href="index.htm">Содержание</a> | <a href="2-2-1.htm">2.2.1</a>
</p>

</body>
</html>
