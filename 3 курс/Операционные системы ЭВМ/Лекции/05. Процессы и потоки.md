В большинстве ОС определены 2 типа единиц работы, между которыми разделятся процессор и другие ресурсы вычислительной системы - это **процесс** (process) и **поток** (thread). Когда программная единица работы будет потреблять все виды ресурсов (устройства ввода-вывода, файлы и др.) кроме одного процессорного времени, будем считать что это **процесс**. Каждый процесс состоит как минимум из одного **потока**, и именно между потоками распределяется процессорное время. Когда понятия потока и процесса совпадают (однопоточный процесс), будем называть это **задачей** (task).  
Большой задачей операционной системы является механизм разделения процессорного времени между потоками. Желательно этот механизм организовать таким образом, чтобы решались 2 задачи: 
1. Использовать процессорное время по возможности на 100% без простоя процессора
2. Организовать распределение процессорного времени так, чтобы более мелкие задачи выполнялись быстрее, чем большие
## Схемы разделения процессорного времени
1. Простая очередь
2. Очередь с блокировкой при обращении к внешним устройствам
3. Круговорот
4. Система динамических приоритетов
## Синхронизация процессов и потоков
**Задача ведения базы данных клиентов некоторого предприятия**: каждому клиенту отводится отдельная запись в базе данных, в которой среди прочих полей имеются поля Заказ и Оплата. Программа, ведущая базу данных, оформлена как единый процесс, имеющий несколько потоков, в том числе поток $A$, который заносит в базу данных информацию о заказах, поступивших от клиентов, и поток $B$, который фиксирует в базе данных сведения об оплате клиентами выставленных счетов. Оба эти потока совместно работают над общим файлом базы данных, используя однотипные алгоритмы, включающие 3 шага:
1. Считать из файла базы данных в буфер запись о клиенте с заданным идентификатором
2. Внести новое значение в поле Заказ (для потока $A$) или Оплата (для потока $B$)
3. Вернуть модифицированную запись в файл базы данных
  
![Синхронизация процессов и потоков](../Pictures/05_01.%20Синхронизация%20процессов%20и%20потоков.png)  
## Средства синхронизации
#### Запрет на все прерывания
На время нахождения потока в критической секции запрещаются все прерывания до тех пор, пока поток из критической секции не выйдет.
#### Блокирующие переменные
![Блокирующие переменные](../Pictures/05_02.%20Блокирующие%20переменные.png)  
Системные функции Windows:
- `InitializeCriticalSection()`
- `EnterCriticalSection()`
- `LeaveCriticalSection()`
#### Семафоры
- $V(S)$: переменная $S$ увеличивается на 1 единым действием. Выборка, наращивание и запоминание не могут быть прерваны. К переменной $S$ нет доступа другим потокам во время выполнения этой операции
- $P(S)$: уменьшение $S$ на 1, если это возможно. Если $S=0$ и невозможно уменьшить $S$, оставаясь в области целых неотрицательных значений, то в этом случае поток, вызывающий операцию $P$, ждет, пока это уменьшение станет возможным. Успешная проверка и уменьшение также являются неделимой операцией
  
![Семафоры](../Pictures/05_03.%20Семафоры.png)  
Системные функции Windows:
- `CreateSemaphore()`
- `OpenSemaphore()`
- `ReleaseSemaphore()`
#### Мьютексы
Системные функции Windows:
- `CreateMutex()`
- `OpenMutex()`
- `ReleaseMutex()`
#### Синхронизация с внешними объектами (файлы и т. д.)
Системные функции Windows:
- `CreateEvent()`
- `OpenEvent()`
- `SetEvent()`
- `ResetEvent()`
- `WaitForSingleObject()`
- `WaitForMultipleObject()`
## Взаимоблокировка процессов
**Взаимоблокировка процессов** (тупик, deadlock) может происходить, когда несколько процессов борются за один ресурс.  
Ресурсы бывают выгружаемые и невыгружаемые, аппаратные и программные.  
**Выгружаемый ресурс** - этот ресурс безболезненно можно забрать у процесса (например, память).  
**Невыгружаемый ресурс** - этот ресурс нельзя забрать у процесса без потери данных (например, принтер).  
Проблема взаимоблокировок процессов возникает при борьбе за невыгружаемые ресурсы.  
Условия, необходимые для взаимоблокировки:
1. **Условие взаимного исключения** - в какой-то момент времени, ресурс занят только одним процессом или свободен
2. **Условие удержания и ожидания** - процесс, удерживающий ресурс, может запрашивать новые ресурсы
3. **Условие отсутствия принудительной выгрузки ресурса**
4. **Условие циклического ожидания** - должна существовать круговая последовательность из процессов, каждый из которого ждет доступа к ресурсу, удерживаемому следующим членом последовательности
#### Методы борьбы с взаимоблокировками
4 стратегии избегания взаимоблокировок:
1. Пренебрежением проблемой в целом (вдруг пронесет). Если вероятность взаимоблокировки очень мала, то ею легче пренебречь, т. к. код исключения может очень усложнить ОС и привести к большим ошибкам. Также многие взаимоблокировки тяжело обнаружить. Этот алгоритм используется как в UNIX, так и в Windows. Поэтому (и не только) на серверах часто устанавливают автоматическую перезагрузку (раз в сутки, как правило ночью), если возникнет взаимоблокировка, то после перезагрузки ее не будет
2. Обнаружение и устранение (взаимоблокировка происходит, но оперативно ликвидируется)
3. Алгоритм банкира. Динамическое избежание тупиков
4. Предотвращение одного из четырех условий, необходимых для взаимоблокировок
#### Моделирование взаимоблокировок
![Моделирование взаимоблокировок](../Pictures/05_04.%20Моделирование%20взаимоблокировок.png)  
На такой модели очень хорошо проверить, возникает ли взаимоблокировка. Если есть цикл, значит есть взаимоблокировка.  
#### Обнаружение и устранение 
Один ресурс каждого типа:  
![Обнаружение и устранение](../Pictures/05_05.%20Обнаружение%20и%20устранение.png)  
Для каждого узла $N$ в графе выполняется 5 шагов:
1. Задаются начальные условия: $L$ - пустой список, все ребра не маркированы
2. Текущий узел добавляем в конец списка $L$ и проверяем количество появления узл