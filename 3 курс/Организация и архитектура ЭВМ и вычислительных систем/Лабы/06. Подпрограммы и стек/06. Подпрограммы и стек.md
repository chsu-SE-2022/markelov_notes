В программировании часто встречаются ситуации, когда одинаковые действия необходимо выполнять многократно в разных частях программы (например, вычисление функции `sin x`). При этом с целью экономии памяти не следует многократно повторять одну и ту же последовательность команд - достаточно один раз написать так называемую **подпрограмму** (в терминах языков высокого уровня - процедуру) и обеспечить правильный вызов этой подпрограммы и возврат в точку вызова по завершению подпрограммы.  
Для **вызова** подпрограммы необходимо указать ее начальный адрес в памяти и передать (если необходимо) параметры - те исходные данные, с которыми будут выполняться предусмотренные в подпрограмме действия. Адрес подпрограммы указывается в команде вызова `CALL`, а параметры могут передаваться через определенные ячейки памяти, регистры или стек.  
**Возврат** в точку вызова обеспечивается сохранением адреса текущей команды (содержимого регистра PC) при вызове и использованием в конце подпрограммы команды возврата `RET`, которая возвращает сохраненное значение адреса возврата в PC.  
Для реализации механизма вложенных подпрограмм (возможность вызова подпрограммы из другой подпрограммы и т. д.) адреса возврата целесообразно сохранять в стеке. **Стек** ("магазин") - особым образом организованная безадресная память, доступ к которой осуществляется через единственную ячейку, называемую **верхушкой стека**. При записи слово помещается в верхушку стека, предварительно все находящиеся в нем слова смещаются вниз на одну позицию; при чтении извлекается содержимое верхушки стека (оно при этом из стека исчезает), а все оставшиеся слова смещаются вверх на одну позицию. Такой механизм напоминает действие магазина стрелкового оружия (отсюда и второе название). В программировании называют такую дисциплину обслуживания LIFO (Last In First Out, последним пришел - первым вышел) в отличие от дисциплины типа **очередь** - FIFO (First In First Out, первым пришел - первым вышел).  
В обычных ОЗУ нет возможности перемещать слова между ячейками, поэтому при организации стека перемещается не массив слов относительно неподвижной верхушки, а верхушка относительно неподвижного массива. Под стек отводится некоторая область ОЗУ, причем адрес верхушки хранится в специальном регистре процессора - указателе стека `SP`.  
В стек можно поместить содержимое регистра общего назначения по команде `PUSH` или извлечь содержимое верхушки в регистр общего назначения по команде `POP`. Кроме того, по команде вызова подпрограммы `CALL` значение программного счетчика `PC` (адрес следующей команды) помещается в верхушку стека, а по команде `RET` содержимое верхушки стека извлекается в `PC`. При каждом обращении в стек указатель `SP` автоматически модифицируется.  
В большинстве ЭВМ стек "растет" в сторону меньших адресов, поэтому перед каждой записью содержимое `SP` уменьшается на 1, а после каждого извлечения содержимое `SP` увеличивается на 1. Таким образом, `SP` всегда указывает на верхушку стека.  
Цель настоящей лабораторной работы - изучение организации программ с использованием подпрограмм. Кроме того, в процессе организации циклов мы будем использовать новые возможности системы команд модели ЭВМ, которые позволяют работать с новым классом памяти - сверхоперативной (регистры общего назначения - РОН). В реальных ЭВМ доступ в РОН занимает значительно меньшее время, чем в ОЗУ; кроме того, команды обращения с регистрами короче команд обращения к памяти. Поэтому в РОН размещаются наиболее часто используемые в программе данные, промежуточные результаты, счетчики циклов, косвенные адреса и т. п.  
В системе команд учебной ЭВМ для работы с РОН используются специальные команды, мнемоники которых совпадают с мнемониками соответствующих команд для работы с ОЗУ, но в адресной части содержат символы регистров `R0`-`R9`.  
Кроме обычных способов адресации (прямой и косвенной) в регистровых командах используются два новых - постинкрементная и преддекрементная. Кроме того, к регистровым относится команда организации цикла `JRNZ R, М`. По этой команде содержимое указанного в команде регистра уменьшается на 1, и если в результате вычитания содержимого регистра не равно 0, то управление передается на метку `М`. Эту команду следует ставить в конце тела цикла, метку `М` - в первой команде тела цикла, а в регистр `R` помещать число повторений цикла.  
## Пример
Даны 3 массива чисел. Требуется вычислить среднее арифметическое их максимальных элементов. Каждый массив задается двумя параметрами: адресом первого элемента и длиной.  
Очевидно, в программе трижды необходимо выполнить поиск максимального элемента массива, поэтому следует написать соответствующую подпрограмму.  
Параметры в подпрограмму будем передавать через регистры: `R1` - начальный адрес массива, `R2` - длина массива.  
Рассмотрим конкретную реализацию этой задачи. Пусть первый массив начинается с адреса `085` и имеет длину 14 элементов, второй - `100` и 4, третий - `110` и 9. Программа будет состоять из основной части и подпрограммы. Основная программа задает параметры подпрограмме, вызывает ее и сохраняет результаты работы подпрограммы в рабочих ячейках. Затем осуществляет вычисление среднего арифметического и выводит результат на устройство вывода. В качестве рабочих ячеек используются регистры общего назначения `R6` и `R7` - для хранения максимальных элементов массивов. Подпрограмма получает параметры через регистры `R1` (начальный адрес массива) и `R2` (длина массива). Эти регистры используются подпрограммой в качестве регистра текущего адреса и счетчика цикла соответственно. Кроме того, `R3` используется для хранения текущего максимума, а `R4` - для временного хранения текущего элемента. Подпрограмма возвращает результат через аккумулятор. В таблице приведен текст основной программы и под- программы. Обратите внимание, цикл в подпрограмме организован с помощью команды `JRNZ`, а модификация текущего адреса - средствами постинкрементной адресации.  

| Команда            | Примечания                           |
| ------------------ | ------------------------------------ |
| Основная программа |                                      |
| `RD #85`           | Загрузка                             |
| `WR R1`            | параметров                           |
| `RD #14`           | первого                              |
| `WR R2`            | массива                              |
| `CALL M`           | Вызов подпрограммы                   |
| `WR R6`            | Сохранение результата                |
| `RD #100`          | Загрузка                             |
| `WR R1`            | параметров                           |
| `RD #4`            | второго                              |
| `WR R2`            | массива                              |
| `CALL M`           | Вызов подпрограммы                   |
| `WR R7`            | Сохранение результата                |
| `RD #110`          | Загрузка                             |
| `WR R1`            | параметров                           |
| `RD #9`            | третьего                             |
| `WR R2`            | массива                              |
| `CALL M`           | Вызов подпрограммы                   |
| `ADD R7`           | Вычисление                           |
| `ADD R6`           | среднего                             |
| `DIV #3`           | арифметического                      |
| `OUT`              | Вывод результата                     |
| `HLT`              | Стоп                                 |
| Подпрограмма `MAX` |                                      |
| `M: RD @R1`        | Загрузка                             |
| `WR R3`            | первого элемента в `R3`              |
| `L2: RD @R1+`      | Чтение элемента и модификация адреса |
| `WR R4`            | Сравнение                            |
| `SUB R3`           | и замена,                            |
| `JS L1`            | если `R3` < `R4`                     |
| `MOV R3, R4`       |                                      |
| `L1: JRNZ R2, L2`  | Цикл                                 |
| `RD R3`            | Чтение результата в `Асс`            |
| `RET`              | Возврат                              |
## Задание
Составить и отладить программу учебной ЭВМ для решения следующей задачи. Три массива в памяти заданы начальными адресами и длинами. Вычислить и вывести на устройство вывода среднее арифметическое параметров этих массивов. 

| Номер варианта | Характеристика последовательности чисел $C_1$ , $C_2$ , . . . , $C_n$ |
| -------------- | --------------------------------------------------------------------- |
| 12             | Номер первого положительного числа                                    |
