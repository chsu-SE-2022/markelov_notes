Данный метод требует фиксированного, обычно малого времени на выполнение операции поиска. Выделяют 2 вида хеширования:
- Открытое, внешнее или расширенное
- Закрытое, внутреннее или прямое
  
Термин "хеширование" произошел от глагола "to hash" - рубить, измельчать, перемешивать. Все множество значений ключа разбивается на $B$ классов, пронумерованных от $0$ до $B-1$. Далее строится хеш-функция $h$, что для любого элемента $x$ из исходного множества ключей функция $h(x)$ принимает целочисленные значения из отрезка от $0$ до $B-1$. Это значение и есть номер класса, в который помещается элемент $x$.
## Открытое хеширование
Хеш-таблица представляет собой $B$ указателей, каждый из которых хранит адрес списка элементов с одним и тем же хешем, равным индексу ячейки. 
Пример:  
```
13, 19, 3, 52, 59, 14, 64, 69, 34
```
$B = 5$, $h(x) = x\%$  
![[03_12. Хеш-таблица.png]]  
Поиск по такой таблице происходит вычислением значения $h(x)$ и прохождением по списку сегмента $x$. Например, нахождение элемента 52 *(да здравствует Санкт-Петербург)* произойдет на 1 шаге. Самые большие проблемы происходят в 4 сегменте. Ситуация, когда 2 элемента имеют один и тот же хеш, называется **коллизией**. Размер таблицы $B$ и вид хеш-функции $h$ обычно выбираются такими, чтобы количество коллизий сводилось к минимуму. 
## Закрытое хеширование
При закрытом хешировании в таблице сегментов хранятся сами элементы. Поэтому в каждом сегменте может находится лишь 1 элемент. А это значит, что в закрытой хеш-таблице не может быть размещено более $B$ элементов, где $B$ - размер таблицы. Кроме того, возникают проблемы в виде коллизий. На помощь приходит **технология повторного хеширования**.  
Если на функции $h_0(x)$ произошла коллизия, к объекту применяются функции $h_1(x)$, $h_2(x)$, ..., пока не будет найдена свободная ячейка. Вид функции для повторного хеширования модет быть например такой: $h_i(x)=(h_0(x)+i)\%B$. При закрытом хешировании