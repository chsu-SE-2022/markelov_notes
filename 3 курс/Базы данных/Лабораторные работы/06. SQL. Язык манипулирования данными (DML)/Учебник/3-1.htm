<html>
<head>
   <title>Запросы с использованием нескольких таблиц</title>

</head>
<body background="fon.jpg">
<div align="center"><b><font>Глава 3. Запросы с использованием нескольких таблиц<br>3.1. О средствах одновременной работы с множеством таблиц</font></b></div><font size = "-1">


<p align=justify>Затрагивая вопросы проектирования баз данных [<a href=liter.htm>2</a>], мы выяснили, что базы данных - это множество взаимосвязанных сущностей или отношений (таблиц) в терминологии реляционных СУБД. При проектировании стремятся создавать таблицы, в каждой из которых содержалась бы информация об одном и только об одном типе сущностей. Это облегчает модификацию базы данных и поддержание ее целостности. Но такой подход тяжело усваивается начинающими проектантами, которые пытаются привязать проект к будущим приложениям и так организовать таблицы, чтобы в каждой из них хранилось все необходимое для реализации возможных запросов. Типичен вопрос: как же получить сведения о том, где купить продукты для приготовления того или иного блюда и определить его калорийность и стоимость, если нужные данные "рассыпаны" по семи различным таблицам? Не лучше ли иметь одну большую таблицу, содержащую все сведения базы данных ПАНСИОН ?</P>
<p align=justify>Даже при отсутствии средств одновременного доступа ко многим таблицам нежелателен проект, в котором информация о многих типах сущностей перемешана в одной таблице. SQL же обладает великолепным механизмом для одновременной или последовательной обработки данных из нескольких взаимосвязанных таблиц. В нем реализованы возможности "соединять" или "объединять" несколько таблиц и так называемые "вложенные подзапросы". Например, чтобы получить перечень поставщиков продуктов, необходимых для приготовления Сырников, возможен запрос</P>

<PRE>
SELECT	Продукт, Цена, Название, Статус
FROM	Продукты, Состав, Блюда, Поставки, Поставщики
WHERE	Продукты.ПР = Состав.ПР
AND	Состав.БЛ = Блюда.БЛ
AND	Поставки.ПР = Состав.ПР
AND	Поставки.ПС = Поставщики.ПС
AND	Блюдо = 'Сырники'
AND	Цена IS NOT NULL;</PRE>

<TABLE>
<TR><th>Продукт</th><TH>Цена</TH><th>Название</TH><th>Статус</TH></TR>
<TR><TD>Яйца</TD><TD>1.8</TD><TD>ПОРТОС</TD><TD>кооператив</TD></TR>
<TR><TD>Яйца</TD><TD>2.</TD><TD>КОРЮШКА</TD><TD>кооператив</TD></TR>
<TR><TD>Сметана</TD><TD>3.6</TD><TD>ПОРТОС</TD><TD>кооператив</TD></TR>
<TR><TD>Сметана</TD><TD>2.2</TD><TD>ОГУРЕЧИК</TD><TD>ферма</TD></TR>
<TR><TD>Творог</TD><TD>1.</TD><TD>ОГУРЕЧИК</TD><TD>ферма</TD></TR>
<TR><TD>Мука</TD><TD>0.5</TD><TD>УРОЖАЙ</TD><TD>коопторг</TD></TR>
<TR><TD>Сахар</TD><TD>0.94</TD><TD>ТУЛЬСКИЙ</TD><TD>универсам</TD></TR>
<TR><TD>Сахар</TD><TD>1.</TD><TD>УРОЖАЙ</TD><TD>коопторг</TD></TR>
</TABLE>

<p align=justify>Он получен следующим образом: СУБД последовательно формирует строки декартова произведения таблиц, перечисленных во фразе FROM, проверяет, удовлетворяют ли данные сформированной строки условиям фразы WHERE, и если удовлетворяют, то включает в ответ на запрос те ее поля, которые перечислены во фразе SELECT.</P>
<p align=justify>Следует подчеркнуть, что в SELECT и WHERE (во избежание двусмысленности) ссылки на все (*)  или отдельные столбцы могут (а иногда и должны) уточняться именем соответствующей таблицы, например, Поставки.ПС, Поставщики.ПС, Меню.*, Состав.БЛ, Блюда.* и т.п.</P>
<p align=justify>Очевидно, что с помощью соединения несложно сформировать запрос на обработку данных из нескольких таблиц. Кроме того, в такой запрос можно включить любые части предложения SELECT, рассмотренные в главе 2 (выражения с использованием функций, группирование с отбором указанных групп и упорядочением полученного результата). Следовательно, соединения позволяют обрабатывать множество взаимосвязанных таблиц как единую таблицу, в которой перемешана информация о многих типах сущностей. Поэтому начинающий проектант базы данных может спокойно создавать маленькие нормализованные таблицы, так как он всегда может получить из них любую "большую" таблицу.</P>
<p align=justify>Кроме механизма соединений в SQL есть механизм вложенных подзапросов, позволяющий объединить несколько простых запросов в едином предложении SELECT. Иными словами, вложенный подзапрос - это уже знакомый нам подзапрос (с небольшими огра-ничениями), который вложен в WHERE фразу другого вложенного подзапроса или WHERE фразу основного запроса.</P>
<p align=justify>Для иллюстрации вложенного подзапроса вернемся к предыдущему примеру и попробуем получить перечень тех поставщиков продуктов для Сырников, которые поставляют нужные продукты за минимальную цену.</P>
<PRE>
SELECT	Продукт, Цена, Название, Статус
FROM	Продукты, Состав, Блюда, Поставки, Поставщики
WHERE	Продукты.ПР = Состав.ПР
AND	Состав.БЛ = Блюда.БЛ
AND	Поставки.ПР = Состав.ПР
AND	Поставки.ПС = Поставщики.ПС
AND	Блюдо = 'Сырники'
AND	Цена = (	SELECT	MIN(Цена)
		FROM	Поставки X
		WHERE	X.ПР = Поставки.ПР );</PRE>

<P>Результат запроса имеет вид</P>

<TABLE>
<TR><th>Продукт</th><TH>Цена</TH><th>Название</TH><th>Статус</TH></TR>
<TR><TD>Яйца</TD><TD>1.8</TD><TD>ПОРТОС</TD><TD>кооператив</TD></TR>
<TR><TD>Сахар</TD><TD>0.94</TD><TD>ТУЛЬСКИЙ</TD><TD>универсам</TD></TR>
<TR><TD>Мука</TD><TD>0.5</TD><TD>УРОЖАЙ</TD><TD>коопторг</TD></TR>
<TR><TD>Сметана</TD><TD>2.2</TD><TD>ОГУРЕЧИК</TD><TD>ферма</TD></TR>
<TR><TD>Творог</TD><TD>1.</TD><TD>ОГУРЕЧИК</TD><TD>ферма</TD></TR>
</TABLE>

<p align=justify>Здесь с помощью подзапроса, размещенного в трех последних строках запроса, описывается процесс определения минимальной цены каждого продукта для Сырников и поиск поставщика, предлагающего этот продукт за такую цену. Механизм реализации подзапросов будет подробно описан в п.<a href=3-3-1.htm>3.3</a>. Там же будет рассмотрено, как и для чего вводится псевдоним X для имени таблицы Поставки.</P>

<p align="center">
<a href="2-5-4.htm">2.5.4</a> | <a href="index.htm">Содержание</a> | <a href="3-2-1.htm">3.2.1</a>
</p>

</body>
</html>
